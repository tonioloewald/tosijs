# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

tosijs (formerly xinjs) is a lightweight (~15kB gzipped) path-based state management library for web applications. It uses proxy-based observers to eliminate binding boilerplate, similar to Redux but simpler. Works with vanilla JS/TS, web components, and integrates with React via react-tosijs.

**Key characteristics:**
- Zero runtime dependencies
- No JSX, transpilation, or virtual DOM required
- Direct DOM manipulation with native HTML and web standards
- Full TypeScript support with strict mode

## Commands

```bash
bun start                   # Dev server with hot reload (https://localhost:8018)
bun test                    # Run all tests
bun test src/foo.test.ts    # Run specific test file
bun run format              # Lint and format code (ESLint --fix + Prettier)
bun run dev.ts --build      # Production build only (runs tests, then exits)
bun run free-port           # Kill process on port 8018
bun pack                    # Create local package tarball for testing
```

**Note:** The dev server requires TLS certificates in `tls/key.pem` and `tls/certificate.pem`.

## Build System

The build system (`dev.ts`) uses Bun's bundler and outputs three formats:
- `dist/index.js` - IIFE for browser/script tags
- `dist/module.js` - ES Module
- `dist/main.js` - CommonJS

TypeScript declarations are generated via `tsc --declaration`. The build runs tests before bundling. Documentation is generated by `docs.js` from markdown files and inline `/*#...#*/` comments into `demo/docs.json`.

## Architecture

```
State (xin) ─────────────────────────────────────────────
    │
    ├── tosi({ key: value })     # Register + get typed proxy (preferred)
    ├── xinProxy({ key: value }) # Alias for tosi()
    ├── observe(path, callback)  # React to state changes
    ├── touch(path)              # Force update notification
    └── bind(element, bindings)  # Connect DOM to state
            │
            ├── fromDOM: path    # Input -> state
            └── toDOM: path      # State -> output
```

**Core modules:**
- `xin.ts` / `xin-proxy.ts` - State management with path-based observers; `tosi()` and `xinProxy()` are the main entry points
- `by-path.ts` - Path parsing and value access (e.g., `'app.user.name'`, `'list[id=123]'`)
- `registry.ts` - Central state object; breaks circular dependency between `xin.ts` and `bind.ts`
- `path-listener.ts` - Observer implementation (`touch()`, `observe()`, `unobserve()`)
- `metadata.ts` - Proxy helpers (`tosiPath()`, `tosiValue()`), binding metadata storage
- `elements.ts` - Element factory functions (`div()`, `span()`, etc.)
- `bind.ts` - Data binding connecting state to DOM
- `list-binding.ts` - Array/list bindings with virtual scrolling and surgical updates
- `component.ts` - Base class for web components
- `css.ts` - CSS generation utilities (`css()`, `vars`, `initVars()`)

### Dual Proxy System (`xin` vs `boxed`)

The library exposes two proxies over the same `registry` object:
- **`xin`** — returns raw values for scalars. `xin.foo.bar` returns the string/number directly.
- **`boxed`** — returns `BoxedScalar` proxies for everything, including primitives. `boxed.foo.bar` has `.value`, `.path`, `.observe()`, etc.

Both are created in `xin.ts` via `regHandler(path, boxScalars)`. The `boxScalars` flag controls whether primitives are wrapped. `tosi()` / `xinProxy()` in `xin-proxy.ts` are sugar for assigning to `xin` and returning from `boxed`.

### Path-Based Observer System

Paths support dot notation (`'app.user.name'`), array indices (`'list[0]'`), and id-paths (`'list[id=123]'`). Observers can be registered with string paths, RegExp patterns, or filter functions.

`touch(path)` propagates upward — touching `'app.user.name'` also notifies observers on `'app.user'` and `'app'`.

### Surgical Array Updates via id-paths

When a list binding specifies `idPath: 'id'`, the proxy `set` handler in `xin.ts` detects mutations inside array items and synthesizes id-path touches (e.g., `'list[id=123].color'`). This allows the list binding to update only the affected DOM element — no diffing or reconciliation needed.

### Registry Pattern

`registry.ts` holds the plain state object and lazy getters (`getXinProxy()`, `getBoxed()`). This breaks the circular dependency between `xin.ts` (which creates the proxies) and `bind.ts` (which needs to access them).

**Key types (in `xin-types.ts`):**
- `BoxedProxy<T>` - Type-safe proxy for state objects and arrays with:
  - `.value` / `.path` - Get underlying value and path string
  - `.observe()`, `.bind()`, `.on()`, `.binding()`, `.listBinding()` - Reactive bindings
  - `.valueOf()`, `.toJSON()` - Type coercion
  - Note: `xinValue`, `xinPath`, `tosiValue`, `tosiPath`, etc. are deprecated; use `.value` / `.path`
- `BoxedScalar<T>` - Lightweight proxy for primitives (string/number/boolean); same API as `BoxedProxy`
- `XinBinding<T>` - Binding specification with `toDOM` and `fromDOM` functions
- `Component` - Abstract base class for web components

## Testing

Tests use Bun's test runner with Happy DOM for DOM environment (configured in `bunfig.toml` and `happydom.ts`). Test files follow the pattern `*.test.ts` in the `src/` directory.

**Happy DOM limitations:**
- Does NOT support `:scope >` CSS selector — use manual child iteration instead
- Elements return `0` for `offsetWidth`/`offsetHeight` — mock with `Object.defineProperty(el, 'offsetHeight', { value: 300, configurable: true })`
- `ListBinding` tests require proxied arrays from `xin['path.to.array']`, not raw arrays (raw arrays lack the `XIN_PATH` metadata)
- Throttled event handlers are unreliable in tests; call methods like `lb.update()` directly

## Component Conventions

- **`static initAttributes`** declares attributes synced to properties with automatic type inference from default values (string, number, boolean).
- **`value`** is a special property, not an attribute. Don't put it in `initAttributes`. Setting it triggers a `change` event and `render()`.
- **`content`** can be a function `({div, span}) => div(...)` or a static node/array. The function form receives a destructurable `elements` proxy.
- **`parts`** is a proxy — `this.parts.foo` finds the element with `part="foo"`.
- **`static formAssociated = true`** enables form integration via `ElementInternals`.
- Components default to shadow DOM. Set `role` in `initAttributes` to use light DOM instead.
- In light DOM, `<slot>` elements are automatically converted to `<xin-slot>` for composition.

## Deprecation Conventions

Deprecated APIs emit a single `console.warn` per feature (tracked in a `Set` in `metadata.ts`). Old names (`xinValue`, `xinPath`, `tosiValue`, `tosiPath`) still work but should not be used in new code. Prefer `.value` and `.path` on `BoxedProxy`/`BoxedScalar`.

## Code Style

- ESLint with TypeScript parser; `any` is allowed (`@typescript-eslint/no-explicit-any: 0`)
- Unused function arguments must be prefixed with `_` (via `argsIgnorePattern`)
- Prettier: single quotes, no semicolons, 2-space indent, trailing commas (ES5)

## Issue Tracking

This project uses **bd (beads)** for issue tracking. Run `bd prime` for full workflow context.

```bash
bd ready                    # Find unblocked work
bd list --status=open       # All open issues
bd show <id>                # View issue details
bd create --title="..." --type=task|bug|feature --priority=2  # Create issue
bd update <id> --status=in_progress  # Claim work
bd close <id>               # Complete work
bd sync                     # Sync with git (run at session end)
```

**Session end protocol:** Always run `bd sync` and `git push` before ending a session. See AGENTS.md for the full checklist.
