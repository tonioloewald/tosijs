[
  {
    "text": "# xinjs\n\n<!--{ \"pin\": \"top\" }-->\n\n<div style=\"text-align: center; margin: 20px\">\n  <a href=\"https://xinjs.net\">\n    <img style=\"width: 200px; max-width: 80%\" alt=\"xinjs logo\" src=\"https://xinjs.net/xinjs-logo.svg\">\n  </a>\n</div>\n\n[xinjs.net](https://xinjs.net) | [xinjs-ui](https://ui.xinjs.net) | [docs](https://github.com/tonioloewald/xinjs/blob/main/docs/_contents_.md) | [github](https://github.com/tonioloewald/xinjs) | [npm](https://www.npmjs.com/package/xinjs) | [cdn](https://www.jsdelivr.com/package/npm/xinjs) | [react-xinjs](https://github.com/tonioloewald/react-xinjs#readme) | [discord](https://discord.gg/ramJ9rgky5)\n\n[![xinjs is on NPM](https://badge.fury.io/js/xinjs.svg)](https://www.npmjs.com/package/xinjs)\n[![xinjs is about 10kB gzipped](https://deno.bundlejs.com/?q=xinjs&badge=)](https://bundlejs.com/?q=xinjs&badge=)\n[![xinjs on jsdelivr](https://data.jsdelivr.com/v1/package/npm/xinjs/badge)](https://www.jsdelivr.com/package/npm/xinjs)\n\nFor a pretty thorough overview of xinjs, you might like to start with [What is xinjs?](https://loewald.com/blog/2025/6/4/what-is-xinjs-).\nTo understand the thinking behind xinjs, there's [What should a front-end framework do?](https://loewald.com/blog/2025/6/4/what-should-a-front-end-framework-do).\n\n### Build UIs with less code\n\n- simple, efficient observer pattern\n- written in TypeScript\n- lightweight\n- works anywhere (browsers, node, bun, electron etc.)\n\nIf you want to build a web-application that's performant, robust, and maintainable,\n`xinjs` lets you:\n\n- implement your business logic however you like (or reuse existing code),\n- build your UI with pure `React` components (using `useXin`)\n- and/or `web-component`s,\n- and _bind_ state to the user-interface _directly_.\n\nIn general, `xinjs` is able to accomplish the same or better compactness, expressiveness,\nand simplicity as you get with highly-refined React-centric toolchains, but without transpilation,\ndomain-specific-languages, or other tricks that provide convenience at the cost of becoming locked-in\nto React, a specific state-management system (which permeats your business logic), and UI framework.\n\nHere's the usual codesandbox `React Typescript` boilerplate [converted to `xinjs`](https://codesandbox.io/s/xinapp-eei48c?file=/src/app.ts).\n\nThe standard [React Todo List Example](https://codesandbox.io/s/xinjs-react-reminders-demo-v0-4-2-l46k52?file=/src/App.tsx)\nbecomes shorter and simpler with `xinjs` and _cleanly separates_ business logic from presentation. `xinjs` **paths** route data to/from UI elements, and events from the UI to methods, and those paths are _exactly what you expect_.\n\nBut xinjs lets you work with pure HTML components as cleanly—more cleanly—and efficiently than\nReact toolchains let you work with JSX.\n\n    export default function App() {\n      return (\n        <div className=\"App\">\n          <h1>Hello React</h1>\n          <h2>Start editing to see some magic happen!</h2>\n        </div>\n      );\n    }\n\nBecomes:\n\n    const { div, h1, h2 } = elements // exported from xinjs\n    export const App = () => div(\n      { class: 'App' },\n      h1('Hello xinjs'),\n      h2('Start editing to see some magic happen!')\n    )\n\nExcept this reusable component outputs native DOM nodes. No transpilation, spooky magic at a distance,\nor virtual DOM required. And it all works just as well with web-components. This is you get when\nyou run App() in the console:\n\n    ▼ <div class=\"App\">\n        <h1>Hello xinjs</h1>\n        <h2>Start editing to see some magic happen!</h2>\n      </div>\n\nThe ▼ is there to show that's **DOM nodes**, not HTML.\n\n`xinjs` lets you lean into web-standards and native browser functionality while writing less code that's\neasier to run, debug, deploy, and maintain. Bind data direct to standard input elements—without having\nto fight their basic behavior—and now you're using _native_ functionality with _deep accessibility_ support\nas opposed to whatever the folks who wrote the library you're using have gotten around to implementing.\n\n> **Aside**: `xinjs` will also probably work perfectly well with `Angular`, `Vue`, et al, but I haven't\n> bothered digging into it and don't want to deal with `ngZone` stuff unless someone is paying\n> me.\n\nIf you want to build your own `web-components` versus use something off-the-rack like\n[Shoelace](https://shoelace.style), `xinjs` offers a `Component` base class that, along with\nits `elements` and `css` libraries allows you to implement component views in pure Javascript\nmore compactly than with `jsx` (and without a virtual DOM).\n\n    import { Component, elements, css } from 'xinjs'\n\n    const { style, h1, slot } = elements\n    export class MyComponent extends Component {\n      styleNode = style(css({\n        h1: {\n          color: 'blue'\n        }\n      }))\n      content = [ h1('hello world'), slot() ]\n    }\n\nThe difference is that `web-components` are drop-in replacements for standard HTML elements\nand interoperate happily with one-another and other libraries, load asynchronously,\nand are natively supported by all modern browsers.\n\n## What `xinjs` does\n\n### Observe Object State\n\n`xinjs` tracks the state of objects you assign to it using `paths` allowing economical\nand direct updates to application state.\n\n    import { xinProxy, observe } from 'xinjs'\n\n    const { app } = xinProxy({\n      app: {\n        prefs: {\n          darkmode: false\n        },\n        docs: [\n          {\n            id: 1234,\n            title: 'title',\n            body: 'markdown goes here'\n          }\n        ]\n      }\n    })\n\n    observe('app.prefs.darkmode', () => {\n      document.body.classList.toggle('dark-mode', app.prefs.darkmode)\n    })\n\n    observe('app.docs', () => {\n      // render docs\n    })\n\n> #### What does `xinProxy` do, and what is a `XinProxy`?\n>\n> `xinProxy` is syntax sugar for assigning something to `xin` (which is a `XinProxyObject`)\n> and then getting it back out again.\n>\n> A `XinProxy` is an [ES Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n> wrapped around an `object` (which in Javascript means anything\n> that has a `constructor` which in particular includes `Array`s, `class` instances, `function`s\n> and so on, but not \"scalars\" like `number`s, `string`s, `boolean`s, `null`, and `undefined`)\n>\n> All you need to know about a `XinProxy` is that it's Proxy wrapped around your original\n> object that allows you to interact with the object normally, but which allows `xinjs` to\n> **observe** changes made to the wrapped object and tell interested parties about the changes.\n>\n> If you want to original object back you can just hold on to a reference or use `xinValue(someProxy)`\n> to unwrap it.\n\n### No Tax, No Packaging\n\n`xinjs` does not modify the stuff you hand over to it… it just wraps objects\nwith a `Proxy` and then if you use `xin` to make changes to those objects,\n`xinjs` will notify any interested observers.\n\n**Note** `xinProxy({foo: {...}})` is syntax sugar for `xin.foo = {...}`.\n\n    import { xinProxy, observe } from 'xinjs'\n    const { foo } = xinProxy({\n      foo: {\n        bar: 17\n      }\n    })\n\n    observe('foo.bar', v => {\n      console.log('foo.bar was changed to', xin.foo.bar)\n    })\n\n    foo.bar = 17        // does not trigger the observer\n    foo.bar = Math.PI   // triggers the observer\n\n### Paths are like JavaScript\n\n`xin` is designed to behave just like a JavaScript `Object`. What you put\ninto it is what you get out of it:\n\n    import { xin, xinValue } from 'xinjs'\n\n    const foo = {bar: 'baz'}\n    xin.foo = foo\n\n    // xin.foo returns a Proxy wrapped around foo (without touching foo)\n    xinValue(xin.foo) === foo\n\n    // really, it's just the original object\n    xin.foo.bar = 'lurman'\n    foo.bar === 'lurman' // true\n\n    // seriously, it's just the original object\n    foo.bar = 'luhrman'\n    xin.foo.bar === 'luhrman' // true\n\n### …but better!\n\nIt's very common to deal with arrays of objects that have unique id values,\nso `xinjs` supports the idea of id-paths\n\n    import { xinProxy, xin } from 'xinjs\n\n    const { app } = xinProxy ({\n      app: {\n        list: [\n          {\n            id: '1234abcd',\n            text: 'hello world'\n          },\n          {\n            id: '5678efgh',\n            text: 'so long, redux'\n          }\n        ]\n      }\n    })\n\n    console.log(app.list[0].text)              // hello world\n    console.log(app.list['id=5678efgh'])       // so long, redux\n    console.log(xin['app.list[id=1234abcd'])   // hello world\n\n### Telling `xin` about changes using `touch()`\n\nSometimes you will modify an object behind `xin`'s back (e.g. for efficiency).\nWhen you want to trigger updates, simply touch the path.\n\n    import { xin, observe, touch } from 'xinjs'\n\n    const foo = { bar: 17 }\n    xin.foo = foo\n    observe('foo.bar', path => console.log(path, '->', xin[path])\n    xin.foo.bar = -2              // console will show: foo.bar -> -2\n\n    foo.bar = 100                 // nothing happens\n    touch('foo.bar')              // console will show: foo.bar -> 100\n\n### CSS\n\n`xinjs` includes utilities for working with css.\n\n    import {css, vars, initVars, darkMode} from 'xinjs'\n    const cssVars = {\n      textFont: 'sans-serif'\n      color: '#111'\n    }\n\n`initVars()` processes an object changing its keys from camelCase to --kabob-case:\n\n    initVars(cssVars) // emits { --text-font: \"sans-serif\", --color: \"#111\" }\n\n`darkMode()` processes an object, taking only the color properties and inverting their luminance values:\ndarkMode(cssVars) // emits { color: '#ededed' }\n\nThe `vars` simply converts its camelCase properties into css variable references\n\n    vars.fooBar // emits 'var(--foo-bar)'\n    calc(`${vars.width} + 2 * ${vars.spacing}`) // emits 'calc(var(--width) + 2 * var(--spacing))'\n\n`css()` processes an object, rendering it as CSS\n\n    css({\n      '.container': {\n        'position', 'relative'\n      }\n    }) // emits .container { position: relative; }\n\n## Color\n\n`xinjs` includes a powerful `Color` class for manipulating colors.\n\n    import {Color} from 'xinjs\n    const translucentBlue = new Color(0, 0, 255, 0.5) // r, g, b, a parameters\n    const postItBackground = Color.fromCss('#e7e79d')\n    const darkGrey = Color.fromHsl(0, 0, 0.2)\n\nThe color objects have computed properties for rendering the color in different ways,\nmaking adjustments, blending colors, and so forth.\n\n## Hot Reload\n\nOne of the nice things about working with the React toolchain is hot reloading.\n`xinjs` supports hot reloading (and not just in development!) via the `hotReload()`\nfunction:\n\n    import {xin, hotReload} from 'xinjs'\n\n    xin.app = {\n      ...\n    }\n\n    hotReload()\n\n`hotReload` stores serializable state managed by `xin` in localStorage and restores\nit (by overlay) on reload. Because any functions (for example) won't be persisted,\nsimply call `hotReload` after initializing your app state and you're good to go.\n\n`hotReload` accepts a test function (path => boolean) as a parameter.\nOnly top-level properties in `xin` that pass the test will be persisted.\n\nTo completely reset the app, run `localStorage.clear()` in the console.\n\n### Types\n\n`xinjs` [type-by-example](https://www.npmjs.com/package/type-by-example) has been\nbroken out into a separate standalone library. (Naturally it works very well with\nxinjs but they are completely independent.)\n\n## Development Notes\n\nYou'll need to install [bun](https://bun.sh/) and [nodejs](https://nodejs.org)),\nand then run `npm install` and `bun install`. `bun` is used because it's\n**fast** and is a really nice test-runner.\n\nTo work interactively on the demo code, use `bun start`. This runs the demo\nsite on localhost.\n\nTo build everything run `bun run make` which builds production versions of the\ndemo site (in `www`) and the `dist` and `cdn` directories.\n\nTo create a local package (for experimenting with a build) run `bun pack`.\n\n### Parcel Occasionally Gets Screwed Up\n\n- remove all the parcel transformer dependencies @parcel/\\*\n- rm -rf node_modules\n- run the update script\n- npx parcel build (which restores needed parcel transformers)\n\n## Related Libraries\n\n- react-xinjs [react-xinjs](https://github.com/tonioloewald/react-xinjs#readme)\n  allows you to use xin's path-observer model in React [ReactJS](https://reactjs.org) apps\n- type-by-example [github](https://github.com/tonioloewald/type-by-example) | [npm](https://www.npmjs.com/package/type-by-example)\n  is a library for declaring types in pure javascript, allowing run-time type-checking.\n- filter-shapes [github](https://github.com/tonioloewald/filter-shapes) | [npm](https://www.npmjs.com/package/filter-shapes)\n  is a library for filtering objects (and arrays of objects) to specific shapes (e.g. to reduce storage / bandwidth costs).\n  It is built on top of type-by-example.\n\n## Credits\n\n`xinjs` is in essence a highly incompatible update to `b8rjs` with the goal\nof removing cruft, supporting more use-cases, and eliminating functionality\nthat has been made redundant by improvements to the JavaScript language and\nDOM APIs.\n\n`xinjs` is being developed using [bun](https://bun.sh/).\n`bun` is crazy fast (based on Webkit's JS engine, vs. V8), does a lot of stuff\nnatively, and runs TypeScript (with import and require) directly.\n",
    "title": "xinjs",
    "filename": "README.md",
    "path": "README.md",
    "pin": "top"
  },
  {
    "text": "# bind\n\n`bind()` lets you synchronize data / application state to the user-interface reliably,\nefficiently, and with a minimum of code.\n\n## An Aside on Reactive Programming vs. the Observer Model\n\nA good deal of front-end code deals with keeping the application's\nstate synchronized with the user-interface. One approach to this problem\nis [Reactive Programming](https://en.wikipedia.org/wiki/Reactive_programming)\nas exemplified by [React](https://reactjs.org) and its many imitators.\n\n`xinjs` works very well with React via the [useXin](./useXin.md) React \"hook\".\nBut `xinjs` is not designed for \"reactive programming\" and in fact \"hooks\" aren't\n\"reactive\" at all, so much as an example of the \"observer\" or \"pub/sub\" pattern.\n\n`xinjs` is a \"path-observer\" in that it's an implementation of the\n[Observer Pattern](https://en.wikipedia.org/wiki/Observer_pattern)\nwhere **path strings** serve as a level of *indirection* to the things observed.\nThis allows data to be \"observed\" before it exists, which in particular *decouples* the setup\nof the user interface from the initialization of data and allows user interfaces\nbuilt with `xinjs` to be *deeply asynchronous*.\n\n## `bind`\n\nThe `bind` function is a simple way of tying an `HTMLElement`'s properties to\nstate via `path` using [bindings](bindings.md)\n\n    import {bind, bindings, xin, elements, updates} from 'xinjs'\n    const {div, input} = elements\n\n    const divElt = div()\n    bind(divElt, 'app.title', bindings.text)\n    document.body.append(divElt)\n\n    const inputElt = input()\n    bind(inputElt, 'app.title', bindings.value)\n\n    xin.app = {title: 'hello world'}\n    await updates()\n\nWhat's happening is essentially the same as:\n\n    divElt.textContent = xin.app.title\n    observe('app.title', () => divElt.textContent = xin.app.title)\n\n    inputElt.value = xin.app.title\n    observe('app.title', () => inputElt.value = xin.app.title)\n    inputElt.addEventListener('change', () => { xin.app.title = inputElt.value })\n\nExcept:\n\n1. this code is harder to write\n2. it will fail if xin.app hasn't been initialized (which it hasn't!)\n3. inputElt will also trigger *debounced* updates on `input` events\n\nAfter this. `div.textContent` and `inputElt.value` are 'hello world'.\nIf the user edits the value of `inputElt` then `xin.app.title` will\nbe updated, and `app.title` will be listed as a changed path, and\nan update will be fired via `setTimout`. When that update fires,\nanything observer of the paths `app.text` and `app` will be fired.\n\nA `binding` looks like this:\n\n    interface XinBinding {\n      toDOM?: (element: HTMLElement, value: any, options?: XinObject) => void\n      fromDOM?: (element: HTMLElement) => any\n    }\n\nSimply put the `toDOM` method updates the DOM based on changes in state\nwhile `fromDOM` updates state based on data in the DOM. Most bindings\nwill have a `toDOM` method but no `fromDOM` method since `bindings.value`\n(which has both) covers most of the use-cases for `fromDOM`.\n\nIt's easy to write your own `bindings` if those in `bindings` don't meet your\nneed, e.g. here's a custom binding that toggles the visibility of an element\nbased on whether the bound value is neither \"falsy\" nor an empty `Array`.\n\n    const visibility = {\n      toDOM(element, value) {\n        if (element.dataset.origDisplay === undefined && element.style.display !== 'none') {\n          element.dataset.origDisplay = element.style.display\n        }\n        element.style.display = (value != null && element.length > 0) ? element.dataset.origDisplay : 'none'\n      }\n    }\n    bind(listElement, 'app.bigList', visibility)",
    "title": "bind",
    "filename": "bind.ts",
    "path": "src/bind.ts"
  },
  {
    "text": "# bindings\n\n`bindings` is simply a collection of common bindings.\n\nYou can create your own bindings easily enough (and add them to `bindings` if so desired).\n\nA `binding` looks like this:\n\n    interface XinBinding {\n      toDOM?: (element: HTMLElement, value: any, options?: XinObject) => void\n      fromDOM?: (element: HTMLElement) => any\n    }\n\nThe `fromDOM` function is only needed for bindings to elements that trigger `change` or `input`\nevents, typically `<input>`, `<textarea>`, and `<select>` elements, and of course your\nown [Custom Elements](web-components.md).\n\nYou can see examples of these bindings in the [kitchen sink demo](../demo/components/kitchen-sink.ts).\n\n## set\n\nThe `set` binding sends state from `xin` to the bound element's `value` property. It's a\n\"one way\" version of the `value` binding. It's recommended for handling compound\nUI elements like dialog boxes or composite custom-elements like a code-editor which might\nhave all kinds of internal elements generating `change` events.\n\n## value\n\nThe `value` binding syncs state from `xin` to the bound element's `value` property. In\ngeneral this should only be used for binding simple things, like `<input>` and `<textarea>`\nelements.\n\n## text\n\nThe `text` binding copies state from `xin` to the bound element's `textContent` property.\n\n## enabled & disabled\n\nThe `enabled` and `disabled` bindings allow you to make a widget's enabled status\nbe determined by the truthiness of something in `xin`, e.g.\n\n```\nimport { xinProxy, elements } from 'xinjs'\n\nconst myDoc = xinProxy({\n    myDoc: {\n        content: ''\n        unsavedChanges: false\n    }\n}, 1)\n\n// this button will only be enabled if there is something in `myList.array`\ndocument.body.append(\n    elements.textarea({\n        bindValue: myDoc.content,\n        onInput() {\n            myDoc.unsavedChanges = true\n        }\n    }),\n    elements.button(\n        'Save Changes',\n        {\n            bindEnabled: myDoc.unsavedChanges,\n            onClick() {\n                // save the doc\n                myDoc.unsavedChanges = false\n            }\n        }\n    )\n)\n```\n\n## list\n\nThe `list` binding makes a copy of a `template` element inside the bound element\nfor every item in the bound `Array`.\n\nIt uses the existing **single** child element it finds inside the bound element\nas its `template`. If the child is a `<template>` (which is a good idea) then it\nexpects that `template` to have a *single child element*.\n\nE.g. if you have a simple unordered list:\n\n    <ul>\n      <li></li>\n    </ul>\n\nYou can bind an array to the `<ul>` and it will make a copy of the `<li>` inside\nfor each item in the source array.\n\nThe `list` binding accepts as options:\n- `idPath: string`\n- `initInstance: (element, item: any) => void`\n- `updateInstance: (element, item: any) => void`\n- `virtual: {width?: number, height: number}`\n- `hiddenProp: symbol | string`\n- `visibleProp: symbol | string`\n\n`initInstance` is called once for each element created, and is passed\nthat element and the array value that it represents.\n\nMeanwhile, `updateInstance` is called once on creation and then any time the\narray value is updated.\n\n### Virtual List Binding\n\nIf you want to bind large arrays with minimal performance impact, you can make a list\nbinding `virtual` by passing the `height` (and optionally `width`) of an item.\nOnly visible elements will be rendered. Just make sure the values passed represent\nthe *minimum* dimensions of the individual rendered items if they can vary in size.\n\nYou can find examples of large, virtual bound arrays in [ArrayBindingsTest.ts](../demo/ArrayBindingTest.ts)\nand [list-filters.ts](../demo/components/list-filters.ts)\n\n### Filtered Lists and Detail Views\n\nYou can **filter** the elements you wish to display in a bound list by using the\n`hiddenProp` (to hide elements of the list) and/or `visibleProp` (to show elements\nof the list).\n\nYou can pass a `path` or a `symbol` as either the `hiddenProp` or `visibleProp`.\n\nTypically, you can use `hiddenProp` to power filters and `visibleProp` to power\ndetail views. The beauty of using symbols is that it won't impact the serialized\nvalues of the array and different views of the array can use different selection\nand filtering criteria.\n\nAn example of a large array bound to a filtered list view using `hiddenProp`\nand a detail view using `visibleProp` can be found in [list-filters.ts](../demo/components/list-filters.ts).\n\n> **Note** for a given list-binding, if you specify `hiddenProp` (but not `visibleProp`),\n> then all items in the array will be shown *unless* `item[hiddenProp] === true`.\n>\n> Conversely, if you specify `visibleProp` (but not `hiddenProp`), then all items\n> in the array will be ignored *unless* `item[visibleProp] === true`.\n>\n> If, for some reason, you specify both then an item will only be visible if\n> it `item[visibleProp] === true` and `item[hiddenProp] !== true`.\n\n### Binding custom-elements using idPath\n\nIf you list-bind a custom-element with `bindValue` implemented and providing an\n`idPath` then the list-binding will bind the array items to the value of the\ncustom-element.\n\nSee [arrayBindingTest.ts](../demo/ArrayBindingTest.ts) for an example of this.\n\n### xin-empty-list class\n\nThe `list` binding will automatically add the class `-xin-empty-list` to a\ncontainer bound to an empty array, making it easier to conditionally render\ninstructions or explanations when a list is empty.",
    "title": "bindings",
    "filename": "bindings.ts",
    "path": "src/bindings.ts"
  },
  {
    "text": "# blueprints\n\nOne issue with standard web-components built with xinjs is that building them\n\"sucks in\" the version of `xinjs` you're working with. This isn't a huge problem\nwith monolithic code-bases, but it does prevent components from being loaded\n\"on-the-fly\" from CDNs and composed on the spot and it does make it hard to\n\"tree shake\" component libraries.\n\nAnother issue is name-collision. What if two people create a `<tab-selector>` component\nand you want to use both of them? Or you want to switch to a new and better one but\ndon't want to do it everywhere all at once?\n\nWith blueprints, the *consumer* of the component chooses the `tag`, reducing the\nchance of name-collision. (You can consume the same blueprint multiple times,\ngiving each one its own tag.)\n\nTo address these issues, `xinjs` provides a `<xin-loader>` loader component and\na function `makeComponent` that can define a component given a blueprint\nfunction.\n\n## `<xin-loader>`—the blueprint loader\n\n`<xin-loader>` is a simple custom-element provided by `xinjs` for the dynamic loading\nof component **blueprints**. It will load its `<xin-blueprint>`s in parallel.\n\n```\n<xin-loader>\n  <xin-blueprint tag=\"swiss-clock\" src=\"https://loewald.com/lib/swiss-clock\"></xin-blueprint>\n</xin-loader>\n<swiss-clock>\n  <code style=\"color: var(--brand-color)\">xinjs</code> rules!\n</swiss-clock>\n```\n\n### `<xin-blueprint>` Attributes\n\n- `src` is the url of the `blueprint` javascript module (required)\n- `tag` is the tagName you wish to use. This defaults to the name of the source file if suitable.\n- `property` allows you to load a named exported property from a blueprint module\n  (allowing one blueprint to export multiple blueprints). By default, it's `default`.\n\n#### `<xin-loader>` and `<xin-blueprint>` Properties\n\n- `onload` is called by `<xin-loader>` when all its blueprints are loaded, and by\n  `<xin-blueprint>` when its blueprint is loaded.\n\n#### Properties\n\n- `onload` is called when all the blueprints have loaded.\n\n## `makeComponent(tag: string, blueprint: XinBlueprint): Promise<XinPackagedCompoent>`\n\n`makeComponent` takes a `tag` of your choice and a `blueprint` and generates\nthe custom-element's `class` and `elementCreator` as its `type` and `creator`\nproperties.\n\nSo, instead of:\n\n    import {myThing} from './path/to/my-thing'\n\n    document.body.append(myThing())\n\nYou could write:\n\n    import { makeComponent } from 'xinjs'\n    import myThingBlueprint from './path/to/my-thing-blueprint'\n\n    makeComponent('different-tag', myThingBlueprint).then((packaged) => {\n      document.body.append(packaged.creator())\n    })\n\n\n## `XinBlueprint`\n\n    export interface XinFactory {\n      Color: typeof Color\n      Component: typeof Component\n      elements: typeof elements\n      svgElements: typeof svgElements\n      mathML: typeof mathML\n      vars: typeof vars\n      varDefault: typeof varDefault\n      xinProxy: typeof xinProxy\n      boxedProxy: typeof boxedProxy\n      version: string\n    }\n\n    export interface XinPackagedComponent {\n      type: typeof Component\n      creator: ElementCreator\n    }\n\n    export type XinBlueprint = (\n      tag: string,\n      module: XinFactory\n    ) => XinPackagedComponent\n\n`XinBlueprint` lets you provide a component \"blueprint\", in the form of a function,\nthat can be loaded and turned into an actual component. The beauty of this is that\nunlike an actual component, the blueprint has no special dependencies.\n\nSo instead of defining a component like this:\n\n    import { Component, elements, vars, varDefault } from 'xinjs'\n\n    const { h2, slot } = elements\n\n    export class MyThing extends Component {\n      static styleSpec = {\n        ':host': {\n          color: varDefault.textColor('#222'),\n          background: vars.bgColor,\n        },\n\n        content = () => [\n          h2('my thing'),\n          slot()\n        ]\n      }\n    }\n\n    export const myThing = myThing.elementCreator({\n      tag: 'my-thing',\n      styleSpec: {\n        _bgColor: '#f00'\n      }\n    })\n\nYou can define a \"blueprint\" like this:\n\n    import { XinBlueprint } from 'xinjs'\n\n    const blueprint: XinBlueprint = (\n      tag,\n      { Component, elements, vars, varDefault }\n    ) => {\n      const {h2, slot} = elements\n\n      class MyThing extends Component {\n        static styleSpec = {\n          ':host': {\n            color: varDefault.textColor('#222'),\n            background: vars.bgColor,\n          },\n\n          content = () => [\n            h2('my thing'),\n            slot()\n          ]\n        }\n      }\n\n      return {\n        type: MyThing,\n        styleSpec: {\n          _bgColor: '#f00'\n        }\n      }\n    }\n\nThe blueprint function can be `async`, so you can use async import inside it to pull in dependencies.\n\n> **Note** that in this example the blueprint is a *pure* function (i.e. it has no side-effects).\n> If this blueprint is consumed twice, each will be completely independent. A non-pure blueprint\n> could be implemented such that the different versions of the blueprint share information.\n> E.g. you could maintain a list of all the instances of any version of the blueprint.",
    "title": "blueprints",
    "filename": "blueprint-loader.ts",
    "path": "src/blueprint-loader.ts"
  },
  {
    "text": "# color\n\n`xinjs` includes a compact (~1.3kB) and powerful `Color` class for manipulating colors.\nThe hope is that when the CSS provides native color calculations this will no\nlonger be needed.\n\n## Color\n\nThe most straightforward method for creating a `Color` instance is using\nthe constructor to create an `rgb` or `rgba` representation.\n\n## Static Methods\n\n`Color.fromCss(cssColor: string): Color` produces a `Color` instance from any\ncss color definition the browser can handle.\n\n`Color.fromHsl(h: number, s: number, l: number, a = 1)` produces a `Color`\ninstance from HSL/HSLA values. The HSL values are cached internally and\nused for internal calculations to reduce precision problems that occur\nwhen converting HSL to RGB and back. It's nowhere near as sophisticated as\nthe models used by (say) Adobe or Apple, but it's less bad than doing all\ncomputations in rgb.\n\n## Properties\n\n- `r`, `g`, `b` are numbers from 0 to 255.\n- `a` is a number from 0 to 1\n\n## Properties (read-only)\n\n- `html` — the color in HTML `#rrggbb[aa]` format\n- `inverse` — the photonegative of the color (light is dark, orange is blue)\n- `inverseLuminance` — inverts luminance but keeps hue, great for \"dark mode\"\n- `rgb` and `rgba` — the color in `rgb(...)` and `rgba(...)` formats.\n- `hsl` and `hsla` — the color in `hsl(...)` and `hsla(...)` formats.\n- `RGBA` and `ARGB` — return the values as arrays of numbers from 0 to 1 for use with\n  [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) (for example).\n- `brightness` — this is the brightness of the color based on [BT.601](https://www.itu.int/rec/R-REC-BT.601)\n- `mono` — this produces a `Color` instance that a greyscale version (based on `brightness`)\n\n## Manipulating Colors\n\nEach of these methods creates a new color instance based on the existing color(s).\n\nIn each case `amount` is from 0 to 1, and `degrees` is an angle (e.g. ± 0 to 360).\n\n- `brighten(amount: number)`\n- `darken(amount: number)`\n- `saturate(amount: number)`\n- `desaturate(amount: number)`\n- `rotate(angle: number)`\n- `opacity(amount: number)` — this just creates a color with that opacity (it doesn't adjust it)\n- `mix(otherColor: Color, amount)` — produces a mix of the two colors in HSL-space\n- `blend(otherColor: Color, amount)` — produces a blend of the two colors in RGB-space (usually icky)\n\nWhere-ever possible, unless otherwise indicated, all of these operations are performed in HSL-space.\nHSL space is not great! For example, `desaturate` essentially blends you with medium gray (`#888`)\nrather than a BT.601 `brightness` value where \"yellow\" is really bright and \"blue\" is really dark.\n\nIf you want to desaturate colors more nicely, you can try blending them with their own `mono`.\n\n## Utilities\n\n- `swatch()` emits the color into the console with a swatch and returns the color for chaining.\n- `toString()` emits the `html` property",
    "title": "color",
    "filename": "color.ts",
    "path": "src/color.ts"
  },
  {
    "text": "# css\n\n`xinjs` provides a collection of utilities for working with CSS rules that\nhelp leverage CSS variables to produce highly maintainable and lightweight\ncode that is nonetheless easy to customize.\n\nThe basic goal is to be able to implement some or all of our CSS very efficiently, compactly,\nand reusably in Javascript because:\n\n- Javascript quality tooling is really good, CSS quality tooling is terrible\n- Having to write CSS in Javascript is *inevitable* so it might as well be consistent and painless\n- It turns out you can get by with *much less* and generally *simpler* CSS this way\n- You get some natural wins this way. E.g. writing two definitions of `body {}` is easy to do\n  and bad in CSS. In Javascript it's simply an error!\n\nThe `css` module attempts to implement all this the simplest and most obvious way possible,\nproviding syntax sugar to help with best-practices such as `css-variables` and the use of\n`@media` queries to drive consistency, themes, and accessibility.\n\n## css(styleMap: XinStyleMap): string\n\nA function that, given a `XinStyleMap` renders CSS code. What is a XinStyleMap?\nIt's kind of what you'd expect if you wanted to represent CSS as Javascript in\nthe most straightforward way possible. It allows for things like `@import`,\n`@keyframes` and so forth, but knows just enough about CSS to help with things\nlike autocompletion of CSS rules (rendered as camelcase) so that, unlike me, it\ncan remind you that it's `whiteSpace` and not `whitespace`.\n\n    import {elements, css} from 'xinjs'\n    const {style} = elements\n\n    const myStyleMap = {\n      body: {\n        color: 'red'\n      },\n      button: {\n        borderRadius: 5\n      }\n    }\n\n    document.head.append(style(css(myStyleMap)))\n\nIf a bare, non-zero **number** is assigned to a CSS property it will have 'px' suffixed\nto it automatically. There are *no bare numeric*ele properties in CSS except `0`.\n\nWhy `px`? Well the other obvious options would be `rem` and `em` but `px` seems the\nleast surprising option.\n\n`css` should render nested rules, such as `@keyframes` and `@media` correctly.\n\n## initVars({[key: string]: any}) => {[key: string]: any}\n\nGiven a map of CSS properties (in camelCase) form emit a map of css-variables to\nthe values, with `px` suffixed to bare numbers where appropriate.\n\n    const cssVars = {\n      textColor: '#222',   // --text-color: #222\n      background: '#eee',  // --background: #eee\n      fontSize: 15         // --font-size: 15px\n    }\n\n    const myStyleMap = {\n      ':root': initVars(cssVars)\n    }\n## darkMode({[key: string]: any}) => {[key: string]: string}\n\nGiven a map of CSS properties (in camelCase) emit a map of those properties that\nhas color values with their luminance inverted.\n\n    const myStyleMap = {\n      ':root': cssVars,               // includes --font-size\n      '@media (prefers-color-scheme: dark)': {\n        ':root': darkMode(cssVars)    // omits --font-size\n      },\n    }\n\n## vars\n\n`vars` is a proxy object that will return a css variable string from\na camelCase property, e.g.\n\n    vars.camelCase // 'var(--camel-case)'\n\n> **it isn't called `var`** because that's a reserved word!\n\n### varDefault\n\n`varDefault` is a proxy object just like `vars` except that it returns a\n`function` that takes a property and renders it as a css variable reference\nwith a default, e.g\n\n    varDefault.borderColor('red') // `var(--border-color, red)`\n\n### Syntax Sugar for `calc(...)`\n\nMore importantly, `vars` allows you to conveniently perform calculations\non css (dimensional) variables by a percentage:\n\n    vars.camelSize50    // 'calc(var(--camel-size) * 0.5)'\n    vars.camelSize_50   // 'calc(var(--camel-size) * -0.5)'\n\n### Computed Colors\n\n> **Caution** although these look superficially like the `vars` syntax\n> sugar for `calc()` performed on dimensional variables, they are in fact\n> color calculations are performed on colors *evaluated* on `document.body`.\n\nYou can write:\n\n    initVars({\n      lineHeight: 24,\n      spacing: 5,\n      buttonHeight: calc(`vars.lineHeight + vars.spacing200`)\n    })\n\nAnd then render this as CSS and stick it into a StyleNode and it will work.\n\nYou *cannot* write:\n\n    initVars({\n      background: '#fafafa',\n      blockColor: vars.background_5b\n    })\n\nBecause `--background` isn't defined on `document.body` yet, so vars.background_5b\nwon't be able to tell what `--background` is going to be yet. So either you need to\ndo this in two stags (create a StyleNode that defines the base color `--background`\nthen define the computed colors and add this) OR use a `Color` instance:\n\n    const background = Color.fromCss('#fafafa')\n\n    initVars({\n      background: background.toHTML,\n      blockColor: background.brighten(-0.05).toHTML\n    })\n\nUntil browsers support color calculations the way they support dimenion arithmetic with `calc()`\nthis is the miserable existence we all lead. That, or defining huge arrays of color\nvalues that we mostly don't use and are often not exactly what we want. You choose!\n\n> **New** color now supports CSS [named colors](https://developer.mozilla.org/en-US/docs/Web/CSS/named-color),\nsuch as `black`, `red`, and `aliceblue`.\n\n`vars` also allows you to perform color calculations on css (color)\nvariables:\n\n#### Change luminance with `b` (for brighten) suffix\n\nThe scale value is treated as a percentage and moves the brightness\nthat far from its current value to 100% (if positive) or 0% (if negattive).\n\n    vars.textColor50b   // increases the luminance of textColor\n    vars.textColor_50b  // halves the luminance of textColor\n\n#### Change saturation with `s` suffix\n\nThe scale value is treated as a percentage and moves the saturation\nthat far from its current value to 100% (if positive) or 0% (if negattive).\n\n    vars.textColor50s   // increases the saturation of textColor\n    vars.textColor_50s  // halves the saturation of textColor\n\n#### Rotate hue with `h` suffix\n\n    vars.textColor30h   // rotates the hue of textColor by 30°\n    vars.textColor_90h  // rotates the hue of textColor by -90°\n\n#### Set Opacity with `o` suffix\n\nUnlike the other modifiers, `o` simply sets the opacity of the\nresulting color to the value provided.\n\n    vars.textColor50o   // textColor with opacity set to 0.5\n\n## More to follow?\n\nThe more I use the `css` module, the more I like it and the more ideas I have\nto make it even better, but I have a very tight size/complexity target\nfor `xinjs` so these new ideas really have to earn a spot. Perhaps the\nfeature I have come closest to adding and then decided against was providing\nsyntax-sugar for classs so that:\n\n    css({\n      _foo: {\n        color: 'red'\n      }\n    })\n\nWould render:\n\n    .foo {\n      color: 'red'\n    }\n\nBut looking at the code I and others have written, the case for this is weak as most class\ndeclarations are not just bare classes. This doesn't help with declarations\nfor `input.foo` or `.foo::after` or `.foo > *` and now there'd be things that\nlook different which violates the \"principle of least surprise\". So, no.\n\n### Something to Declare\n\nWhere I am always looking to improve this module (and all of `xinjs`) is to\ndo a better job of **declaring** things to improve autocomplete behavior and\nminimize casting and other Typescript antipatterns. E.g. adding a ton of\ndeclarations to `elements` and `css` has done wonders to reduce the need for\nstuff like `const nameElement = this.parts.nameField as unknown as HTMLInputElement`\nand prevent css property typos without adding a single byte to the size of\nthe javascript payload.",
    "title": "css",
    "filename": "css.ts",
    "path": "src/css.ts"
  },
  {
    "text": "# elements\n\n`xinjs` provides `elements` for easily and efficiently generating DOM elements\nwithout using `innerHTML` or other unsafe methods.\n\n    import {elements} from 'xinjs'\n\n    const {label, span, input} = elements\n\n    document.body.append(\n      label(\n      {style: {\n        display: 'inline-flex'\n      }},\n      span('This is a field'),\n      input({value: 'hello world', placeholder: 'type something'})\n      )\n    )\n\n`elements` is a proxy whose properties are element factory functions,\nso `elements.foo` is a function that returns a `<foo>` element.\n\nThe arguments of the factory functions can be strings, numbers, other\nelements, or property-maps, which are converted into attributes or properties.\n\nE.g.\n\n    const {span} = elements\n    span('foo')                   // produces <span>foo</foo>\n    span('bar', {class: 'foo'})   // produces <span class=\"foo\">bar</span>\n    button('click me', {\n      onclick() {\n        alert('you clicked me')\n      }\n    })                            // creates a button with an event handler\n    input({\n      type: 'checkbox',\n      checked: true\n    })                            // produces a checked checkbox\n\n## camelCase conversion\n\nAttributes in camelCase, e.g. `dataInfo`, will be converted to kebab-case,\nso:\n\n    span({dataInfo: 'foo'})        // produces <span data-ref=\"foo\"></span>\n\n## style properties\n\n`style` properties can be objects, and these are used to modify the\nelement's `style` object (while a string property will just change the\nelement's `style` attribute, eliminating previous changes).\n\n  span({style: 'border: 1px solid red'}, {style: 'font-size: 15px'})\n\n…produces `<span style=\"font-size: 15px\"></span>`, which is probably\nnot what was wanted.\n\n  span({style: {border: '1px solid red'}, {style: {fontSize: '15px'}}})\n\n…produces `<span style=\"border: 1px solid red; fon-size: 15px></span>`\nwhich is probably what was wanted.\n\n## event handlers\n\nProperties starting with `on` (followed by an uppercase letter)\nwill be converted into event-handlers, so `onMouseup` will be\nturned into a `mouseup` listener.\n\n## binding\n\nYou can [bind](bind.md) an element to state using [bindings](bindings.md)\nusing convenient properties, e.g.\n\n    import { elements } from 'xinjs'\n    const {div} = elements\n    div({ bindValue: 'app.title' })\n\n…is syntax sugar for:\n\n    import { elements, bind, bindings } from 'xinjs'\n    const { div } = elements\n    bind( div(), 'app.title', bindings.value )\n\nIf you want to use your own bindings, you can use `apply`:\n\n    const visibleBinding = {\n      toDOM(element, value) {\n        element.classList.toggle('hidden', !value)\n      }\n    }\n\n    div({ apply(elt){\n      bind(elt, 'app.prefs.isVisible', visibleBinding})\n    } })\n\n## apply\n\nA property named `apply` is assumed to be a function that will be called\non the element.\n\n    span({\n      apply(element){ element.textContent = 'foobar'}\n    })\n\n…produces `<span>foobar</span>`.\n\n## fragment\n\n`elements.fragment` is produces `DocumentFragment`s, but is otherwise\njust like other element factory functions.\n\n## svgElements\n\n`svgElements` is a proxy just like `elements` but it produces **SVG** elements in\nthe appropriate namespace.\n\n## mathML\n\n`mathML` is a proxy just like `elements` but it products **MathML** elements in\nthe appropriate namespace.\n\n> ### Caution\n>\n> Both `svgElements` and `mathML` are experimental and do not have anything like  the\n> degree of testing behind them as `elements`. In particular, the properties of\n> SVG elements (and possible MathML elements) are quite different from ordinary\n> elements, so the underlying `ElementCreator` will never try to set properties\n> directly and will always use `setAttribute(...)`.\n>\n> E.g. `svgElements.svg({viewBox: '0 0 100 100'})` will call `setAttribute()` and\n> not set the property directly, because the `viewBox` property is… weird, but\n> setting the attribute works.\n>\n> Again, use with caution!",
    "title": "elements",
    "filename": "elements.ts",
    "path": "src/elements.ts"
  },
  {
    "text": "# throttle & debounce\n\nUsage:\n\n    const debouncedFunc = debounce(func, 250)\n    const throttledFunc = debounce(func, 250)\n\n`throttle(voidFunc, interval)` and `debounce(voidFunc, interval)` are utility functions for\nproducing functions that filter out unnecessary repeated calls to a function, typically\nin response to rapid user input, e.g. from keystrokes or pointer movement.\n\nThe usual purpose of these functions is to prevent over-calling of a function based on\nrapidly changing data, such as keyboard event or scroll event handling.\n\n`debounce`ed functions will only actually be called `interval` ms after the last time the\nwrapper is called.\n\nE.g. if the user types into a search field, you can call a `debounce`ed\nfunction to do the query, and it won't fire until the user stops typing for `interval` ms.\n\n`throttle`ed functions will only called at most every `interval` ms.\n\nE.g. if the user types into a search field, you can call a `throttle`ed function\nevery `interval` ms, including one last time after the last time the wrapper is called.\n\n> In particular, both throttle and debounce are guaranteed to execute the\n> wrapped function after the last call to the wrapper.\n\nNote that parameters will be passed to the wrapped function, and that *the last call always goes through*.\nHowever, parameters passed to skipped calls will *never* reach the wrapped function.",
    "title": "throttle & debounce",
    "filename": "throttle.ts",
    "path": "src/throttle.ts"
  },
  {
    "text": "# web-components\n\n**xinjs** provides the abstract `Component` class to make defining custom-elements\neasier.\n\n## Component\n\nTo define a custom-element you can subclass `Component`, simply add the properties\nand methods you want, with some help from `Component` itself, and then simply\nexport your new class's `elementCreator()` which is a function that defines your\nnew component's element and produces instances of it as needed.\n\n    import {Component} from 'xinjs'\n\n    class ToolBar extends Component {\n      static styleSpec = {\n        ':host': {\n          display: 'flex',\n          gap: '10px',\n        },\n      }\n    }\n\n    export const toolBar = ToolBar.elementCreator({ tag: 'tool-bar' })\n\nThis component is just a structural element. By default a `Component` subclass will\ncomprise itself and a `<slot>`. You can change this by giving your subclass its\nown `content` template.\n\nThe last line defines the `ToolBar` class as the implementation of `<tool-bar>`\nHTML elements (`tool-bar` is derived automatically from the class name) and\nreturns an `ElementCreator` function that creates `<tool-bar>` elements.\n\nSee [elements](./elements.md) for more information on `ElementCreator` functions.\n\n### Component properties\n\n#### content: Element | Element[] | () => Element | () => Element[] | null\n\nHere's a simple example of a custom-element that simply produces a\n`<label>` wrapped around `<span>` and an `<input>`. Its value is synced\nto that of its `<input>` so the user doesn't need to care about how\nit works internally.\n\n    const {label, span, input} = Component.elements\n\n    class LabeledInput extends Component {\n      caption: string = 'untitled'\n      value: string = ''\n\n      constructor() {\n        super()\n        this.initAttributes('caption')\n      }\n\n      content = label(span(), input())\n\n      connectedCallback() {\n        super.connectedCallback()\n        const {input} = this.parts\n        input.addEventListener('input', () => {\n          this.value = input.value\n        })\n      }\n\n      render() {\n        super.render()\n        const {span, input} = this.parts\n        span.textContent = this.caption\n        if (input.value !== this.value) {\n          input.value = this.value\n        }\n      }\n    }\n\n    export const labeledInput = LabeledInput.elementCreator()\n\n`content` is, in essence, a template for the internals of the element. By default\nit's a single `<slot>` element. If you explicitly want an element with no content\nyou can set your subclass's content to `null` or omit any `<slot>` from its template.\n\nBy setting content to be a function that returns elements instead of a collection\nof elements you can take customize elements based on the component's properties.\nIn particular, you can use `onXxxx` syntax sugar to bind events.\n\n(Note that you cannot bind to xin paths reliably if your component uses a `shadowDOM`\nbecause `xin` cannot \"see\" elements there. As a general rule, you need to take care\nof anything in the `shadowDOM` yourself.)\n\nIf you'd like to see a more complex example along the same lines, look at\n[labeled-input.ts](../demo/components/labeled-input.ts).\n\n##### <slot> names and the `slot` attribute\n\n    const {slot} = Component.elements\n    class MenuBar extends Component {\n      static styleSpec = {\n        ':host, :host > slot': {\n          display: 'flex',\n        },\n        ':host > slot:nth-child(1)': {\n          flex: '1 1 auto'\n        },\n      }\n\n      content = [slot(), slot({name: 'gadgets'})]\n    }\n\n    export menuBar = MenuBar.elementCreator()\n\nOne of the neat things about custom-elements is that you can give them *multiple*\n`<slot>`s with different `name` attributes and then have children target a specific\nslot using the `slot` attribute.\n\n[app-layout.ts](../demo/components/app-layout.ts) is a more complex example of a\nstructural element utilizing multiple named `<slot>`s.\n\n#### `<xin-slot>`\n\nIf you put `<slot>` elements inside a `Component` subclass that doesn't have a\nshadowDOM, they will automatically be replaced with `<xin-slot>` elements that\nhave the expected behavior (i.e. sucking in children in based on their `<slot>`\nattribute).\n\n`<xin-slot>` doesn't support `:slotted` but since there's no shadowDOM, just\nstyle such elements normally, or use `xin-slot` as a CSS-selector.\n\nNote that you cannot give a `<slot>` element attributes (other than `name`) so if\nyou want to give a `<xin-slot>` attributes (such as `class` or `style`), create it\nexplicitly (e.g. using `elements.xinSlot()`) rather than using `<slot>` elements\nand letting them be switched out (because they'll lose any attributes you give them).\n\nAlso see the [faux-slot example](/demo/faux-slots.ts).\n\n> ##### Background\n>\n> `<slot>` elements do not work as expected in shadowDOM-less components. This is\n> hugely annoying since it prevents components from composing nicely unless they\n> have a shadowDOM, and while the shadowDOM is great for small widgets, it's\n> terrible for composite views and breaks `xinjs`'s bindings (inside the shadow\n> DOM you need to do data- and event- binding manually).\n\n#### styleNode: HTMLStyleElement\n\n`styleNode` is the `<style>` element that will be inserted into the element's\n`shadowRoot`.\n\nIf a `Component` subclass has no `styleNode`, no `shadowRoot` will be\ncreated. This reduces the memory and performance cost of the element.\n\nThis is to avoid the performance/memory costs associated with the `shadowDOM`\nfor custom-elements with no styling.\n\n##### Notes\n\nStyling custom-elements can be tricky, and it's worth learning about\nhow the `:host` and `:slotted()` selectors work.\n\nIt's also very useful to understand how CSS-Variables interact with the\n`shadowDOM`. In particular, CSS-variables are passed into the `shadowDOM`\nwhen other CSS rules are not. You can use css rules to modify css-variables\nwhich will then penetrate the `shadowDOM`.\n\n#### refs: {[key:string]: Element | undefined}\n\n    render() {\n      super.render() // see note\n      const {span, input} = this.parts\n      span.textContent = this.caption\n      if (input.value !== this.value) {\n        input.value = this.value\n      }\n    }\n\n> **Note**: the `render()` method of the base `Component` class doesn't currently\n> do anything, so calling it is optional (but a good practice in case one day…)\n>\n> It is *necessary* however to call `super.connectedCallback`, `super.disconnectedCallback`\n> and `super()` in the `constructor()` should you override them.\n\n`this.parts` returns a proxy that provides elements conveniently and efficiently. It\nis intended to facilitate access to static elements (it memoizes its values the\nfirst time they are computed).\n\n`this.parts.foo` will return a content element with `data-ref=\"foo\"`. If no such\nelement is found it tries it as a css selector, so `this.parts['.foo']` would find\na content element with `class=\"foo\"` while `this.parts.h1` will find an `<h1>`.\n\n`this.parts` will also remove a `data-ref` attribute once it has been used to find\nthe element. This means that if you use all your refs in `render` or `connectedCallback`\nthen no trace will remain in the DOM for a mounted element.\n\n### Component methods\n\n#### initAttributes(...attributeNames: string[])\n\n    class LabeledInput extends Component {\n      caption: string = 'untitled'\n      value: string = ''\n\n      constructor() {\n        super()\n        this.initAttributes('caption')\n      }\n\n      ...\n    }\n\nSets up basic behavior such as queueing a render if an attribute is changed, setting\nattributes based on the DOM source, updating them if they're changed, implementing\nboolean attributes in the expected manner, and so forth.\n\nCall `initAttributes` in your subclass's `constructor`, and make sure to call `super()`.\n\n#### queueRender(triggerChangeEvent = false): void\n\nUses `requestAnimationFrame` to queue a call to the component's `render` method. If\ncalled with `true` it will also trigger a `change` event.\n\n#### private initValue(): void\n\n**Don't call this!** Sets up expected behavior for an `HTMLElement` with\na value (i.e. triggering a `change` events and `render` when the `value` changes).\n\n#### private hydrate(): void\n\n**Don't call this** Appends `content` to the element (or its `shadowRoot` if it has a `styleNode`)\n\n#### connectedCallback(): void\n\nIf the class has an `onResize` handler then a ResizeObserver will trigger `resize`\nevents on the element when its size changes and `onResize` will be set up to respond\nto `resize` events.\n\nAlso, if the subclass has defined `value`, calls `initValue()`.\n\n`connectedCallback` is a great place to attach **event-handlers** to elements in your component.\n\nBe sure to call `super.connectedCallback()` if you implement `connectedCallback` in the subclass.\n\n#### disconnectedCallback(): void\n\nBe sure to call `super.disconnectedCallback()` if you implement `disconnectedCallback` in the subclass.\n\n#### render(): void\n\nBe sure to call `super.render()` if you implement `render` in the subclass.\n\n### Component static properties\n\n#### Component.elements\n\n    const {label, span, input} = Component.elements\n\nThis is simply provided as a convenient way to get to [elements](./elements.md)\n\n### Component static methods\n\n#### Component.elementCreator(options? {tag?: string, styleSpec: XinStyleSheet}): ElementCreator\n\n    export const toolBar = ToolBar.elementCreator({tag: 'tool-bar'})\n\nReturns a function that creates the custom-element. If you don't pass a `tag` or if the provided tag\nis already in use, a new unique tag will be used.\n\nIf no tag is provided, the Component will try to use introspection to \"snake-case\" the\n\"ClassName\", but if you're using name mangling this won't work and you'll get something\npretty meaningless.\n\nIf you want to create a global `<style>` sheet for the element (especially useful if\nyour component doesn't use the `shadowDOM`) then you can pass `styleSpec`. E.g.\n\n    export const toolBar = ToolBar.elementCreator({\n      tag: 'tool-bar',\n      styleSpec: {\n        ':host': { // note that ':host' will be turned into the tagName automatically!\n          display: 'flex',\n          padding: 'var(--toolbar-padding, 0 8px)',\n          gap: '4px'\n        }\n      }\n    })\n\nThis will—assuming \"tool-bar\" is available—create:\n\n    <style id=\"tool-bar-helper\">\n      tool-bar {\n        display: flex;\n        padding: var(--toolbar-padding, 0 8px);\n        gap: 4px;\n      }\n    <style>\n\nAnd append it to `document.head` when the first instance of `<tool-bar>` is inserted in the DOM.\n\nFinally, `elementCreator` is memoized and only generated once (and the arguments are\nignored on all subsequent calls).\n\n## Examples\n\nIn proving out `Component` I've built a number of examples.\n\n- [app-layout](../demo/components/app-layout.ts) uses multiple named slots to implement\n  a typical app-layout with header, footer, sidebars, etc.\n- [babylon3d](../demo/components/babylon3d.ts) implements a whole family of components\n  (inspired by [a-frame](https://aframe.io)) that lets you assemble interactive 3d scenes.\n  Aside from the core `<b-3d>` element, none of the other elements are actually displayed.\n- [game-controller.ts](../demo/components/game-controller.ts) is an invisible element that\n  implements basic game-controller functions (loosely based on [unity3d](https://unity3d.com)'s\n  game controls).\n- [labeled-input](../demo/components/labeled-input.ts) is what you'd expect.\n- [labeled-value](../demo/components/labeled-input.ts) is like labeled-input but read-only.\n- [markdown-viewer](../demo/components/markdown-viewer.ts) renders markdown.\n- [toolbar.ts](../demo/components/toolbar.ts) is a simple toolbar container.",
    "title": "web-components",
    "filename": "component.ts",
    "path": "src/component.ts"
  },
  {
    "text": "# xin\n\n> In Mandarin, \"xin\" has several meanings including \"truth\" and \"message\".\n\n`xin` is a path-based implementation of the **observer** or **pub/sub**\npattern designed to be very simple and straightforward to use, leverage\nTypescript type-checking and autocompletion, and let you get more done with\nless code and no weird build magic (such as special decorators or \"execution zones\").\n\n## In a nutshell\n\n[sandbox example](https://codesandbox.io/s/xintro-mh4rbj?file=/src/index.ts)\n\nThink of xin as being an `object`, so you can just assign values to it:\n\n    import { xin } from 'xinjs'\n\n    // typically you won't set a \"root-level\" property to a simple scalar value like this\n    xin.x = 17\n\n    // more commonly you'll assign large chunks of your application state, if not its\n    // entire state to a \"root-level\" property.\n    xin.app = {\n      prefs: {\n        darkMode: false\n      },\n      docs: [\n        {\n          title: 'my novel',\n          content: 'It was a dark and stormy night…'\n        },\n        {\n          title: 'my poem',\n          content: 'Let us go then, you and I, when the evening is spread out against the sky…'\n        }\n      ]\n    }\n\nOnce an object is assigned to  `xin`, changing it within `xin` is simple:\n\n    xin.x = Math.PI\n\n    xin.app.docs[1].title = 'The Love Song of J. Alfred Prufrock'\n\nBut any changes can be observed by writing an observer:\n\n    import { observe } from 'xinjs'\n\n    observe('app.docs', (path) => {\n      console.log(path, 'is now', xin[path])\n    })\n\nNow, if you sneakily make changes behind `xin`'s back, e.g. by modifying the values\ndirectly, e.g.\n\n    const emails = await getEmails()\n    xin.emails = emails\n\n    // notes that xin.emails is really JUST emails\n    emails.push(...)\n    emails.splice(...)\n    emails[17].from = '...'\n\nThen `xin` won't know and observers won't fire. So you can simply `touch` the path\nimpacted:\n\n    import { touch } from 'xinjs'\n    touch('emails')\n\n## boxedProxy()\n\nAfter working with `xin` and using `Typescript` for an extended period, I've tried to\nimprove the type declarations to minimize the amount of casting and `// @ts-ignore-error`\ndirectives needed. The latest result of all this is `boxedProxy`.\n\n`boxedProxy(foo)` is simply declared as a function that takes an object of type T and\nreturns a XinProxy<T>.\n\n    import { boxedProxy } from 'xinjs'\n\n    const { foo, bar } = boxedProxy({\n      foo: 'bar',\n      bar: {\n        director: 'luhrmann'\n      }\n    })\n\nThis is syntax sugar for:\n\n    import { boxed } from 'xinjs'\n\n    const stuff = {\n      foo: 'bar',\n      bar: {\n        director: 'luhrmann',\n        born: 1962\n      }\n    }\n\n    Object.assign(boxed, stuff)\n\n    const { foo, bar } = boxed as XinProxy<typeof stuff>\n\nSo, Typescript will know that `foo` is a `XinProxy<String>`, and `bar.born` is a `XinProxy<Number>`.\n\n## How it works\n\n`xin` is a `Proxy` wrapped around a bare object: effectively a map of strings to values.\n\nWhen you access the properties of an object assigned to `xin` it wraps the values in\nsimilar proxies, and tracks the **path** that got you there:\n\n    xin.foo = {\n      bar: 'baz',\n      luhrman: {\n        job: 'director'\n      }\n    }\n\nNow if you pull objects back out of `xin`:\n\n    let foo = xin.foo\n    let luhrman = foo.luhrman\n\n`foo` is a `Proxy` wrapped around the original *untouched* object, and it knows it came from 'foo'.\nSimilarly `luhrman` is a `Proxy` that knows it came from 'foo.luhrman'.\n\nIf you **change** a value in a wrapped object, e.g.\n\n    foo.bar = 'bob'\n    luhrman.job = 'writer'\n\nThen it will trigger any observers looking for relevant changes. And each change will fire the observer\nand tell it the `path` that was changed. E.g. an observer watching `lurman` will be fired if `lurman`\nor one of `lurman`'s properties is changed.\n\n## Boxed Proxies\n\n`boxed` is a sister to `xin` that wraps \"scalar\" values (`boolean`, `number`, `string`) in\nobjects. E.g. if you write something like:\n\n    xin.test = { answer: 42 }\n    boxed.box = { pie: 'apple' }\n\nThen:\n\n    xin.test.answer === 42\n    xin.box.pie === 'apple'\n    // box wraps \"scalars\" in objects\n    boxed.test.answer.valueOf() === 42\n    boxed.box.pie.valueOf() === 'apple'\n    // anything that comes out of boxed has a path!\n    xinPath(boxed.test.answer) === 'test.answer'\n    xinPath(boxed.box.pie) === 'box.pie'\n\nAside from always \"boxing\" scalar values, `boxed` works just like `xin`.\n\nAnd `xinProxy` will return a `boxed` proxy if you pass `true` as a second parameter, so:\n\n    const { prox } = xinProxy({\n        prox: {\n            message: 'hello'\n        }\n    }, true)\n\n> This is deprecated in favor of `boxedProxy(...)` which is declared in such a way\n> that Typescript will be more helpful.\n\nWill give you a proxy that emits boxed scalars.\n\n### Why?!\n\nAs far as Typescript is concerned, `xinProxy` just passes back what you put into it,\nwhich means that you can now write bindings with type-checking and autocomplete and\nnever use string literals. So something like this *just works*:\n\n    const div = elements.div({bindText: prox.message})\n\n## If you need the thing itself or the path to the thing…\n\n`Proxy`s returned by `xin` are typically indistinguishable from the original object, but\nin a pinch `xinPath()` will give you the path (`string`) of a `XinProxy` while `xinValue`\nwill give its \"bare\" value. `xinPath()` can also be used to test if something is actually\na proxy, as it will return `undefined` for regular objects.\n\nE.g.\n\n    xinPath(luhrman) === 'foo.luhrman'     // true\n    const bareLurhman = xinValue(luhrman)  // not wrapped\n\nYou may want the thing itself to, for example, perform a large number of changes to an\nobject without firing observers. You can let `xin` know you've made changes behind its back using\n`touch`, e.g.\n\n    doTerribleThings(xinValue(luhrman))\n    // eslint-disable-next-line\n    touch(luhrman)\n\n## id-paths\n\nThere's one more wrinkle in `xin`'s paths, and that is **id-paths**. This is because in many cases\nyou will encounter large arrays of objects, each with a unique id somewhere, e.g. it might be `id` or `uid`\nor even buried deeper…\n\n    xin.message = [\n      {\n        id: '1234abcd',\n        title: 'hello',\n        body: 'hello there!'\n      },\n      …\n    ]\n\nInstead of referring to the first item in `messages` as `messages[0]` it can be referred to\nas `messages[id=1234abcd]`, and this will retrieve the item regardless of its position in messages.\n\n### `touch`, `observe` and `unobserve`\n\n`touch`, `observe` and `unobserve` provide low level access to the `xin` observer model. `touch(path: touchable)` allows you to directly inform `xin` that the value at a specified path has changed. You might want to update a large data structure directly without firing observers. You can let `xin` know you've made changes behind its back using `touch`, e.g.\n\n    doTerribleThings(xin.luhrman)\n    touch(xin.luhrman)\n\nWhat's `touchable`? A string (id-path) or a xin observer proxy.\n\n`observe(path: string | RegExp | PathTestFunction, callback: function): Listener` allows you to directly observe changes to a path (or any path that matches a RegExp or PathTestFunction evalutes as true) and trigger a callback which will be passed the path that actually changed. `unobserve(listener: Listener)` removes the listener.\n\n### `async updates()`\n\n`updates` is an async function that resolves after the next UI update. This is for a case where you expect a change you've made to trigger UI changes and you want to act after those have occurred. Typically, this is simply not needed, but it's very useful for testing when you want to change an observed value and verify that your UI widget has updated correctly.\n\n> ## `isValidPath(path: string): boolean`\n>\n> This is an internally used function that validates a path string. It's used in testing and may be useful at runtime.\n>\n> ## `settings: { perf: boolean, debug: boolean }`\n>\n> This is a (so far) internally used configuration object. It's used in testing and may be useful at runtime. Eventually it will allow you to make path resolution and so forth easier to debug and performance tune.",
    "title": "xin",
    "filename": "xin.ts",
    "path": "src/xin.ts"
  },
  {
    "text": "# todo\n\n## work in progress\n\n<!--{ \"pin\": \"bottom\" }-->\n\n- change `MutationObserver` in Component if there's an `onDomChanged`\n  or something handler to trigger it as appropriate\n- automated golden tests?\n- `css()` should handle multiple `@import`s\n- possibly leverage component static property method (if we can keep type preservation)\n\n## known issues\n\n- bindList cloning doesn't duplicate svgs for some reason\n",
    "title": "todo",
    "filename": "TODO.md",
    "path": "TODO.md",
    "pin": "bottom"
  }
]