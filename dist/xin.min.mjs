const stringify=e=>{try{return JSON.stringify(e)}catch(e){return"{has circular references}"}},makeError=(...e)=>new Error(e.map(stringify).join(" ")),now36=()=>new Date(parseInt("1000000000",36)+Date.now()).valueOf().toString(36).slice(1);let _seq=0;const seq=()=>(parseInt("10000",36)+ ++_seq).toString(36).substr(-5),id=()=>now36()+seq(),_delete_={},_newObject_={};function pathParts(e){if(!e)return[];if(Array.isArray(e))return e;{const r=[];for(;e.length;){var t=e.search(/\[[^\]]+\]/);if(-1===t){r.push(e.split("."));break}{const n=e.substr(0,t);e=e.substr(t),n&&r.push(n.split(".")),t=e.indexOf("]")+1,r.push(e.substr(1,t-2)),"."===e.substr(t,1)&&(t+=1),e=e.substr(t)}}return r}}const idPathMaps=new WeakMap;function buildIdPathValueMap(e,t){e&&!idPathMaps.get(e)&&idPathMaps.set(e,{}),idPathMaps.get(e)[t]||(idPathMaps.get(e)[t]={});const r=idPathMaps.get(e)[t];return"_auto_"===t?e.forEach((e,t)=>{void 0===e._auto_&&(e._auto_=id()),r[e._auto_+""]=t}):e.forEach((e,n)=>{r[getByPath(e,t)+""]=n}),r}function getIdPathMap(e,t){return idPathMaps.get(e)&&idPathMaps.get(e)[t]?idPathMaps.get(e)[t]:buildIdPathValueMap(e,t)}function keyToIndex(e,t,r){r+="";let n=getIdPathMap(e,t)[r];return void 0!==n&&getByPath(e[n],t)+""===r||(n=buildIdPathValueMap(e,t)[r]),n}function byKey(e,t,r){return e[t]||(e[t]=r),e[t]}function byIdPath(e,t,r,n){let s=t?keyToIndex(e,t,r):r;if(n===_delete_)return e.splice(s,1),idPathMaps.delete(e),Symbol("deleted");if(n===_newObject_)t||e[s]||(e[s]={});else if(n)if(void 0!==s)e[s]=n;else{if(!t||getByPath(n,t)+""!=r+"")throw new Error(`byIdPath insert failed at [${t}=${r}]`);e.push(n),s=e.length-1}return e[s]}function expectArray(e){if(!Array.isArray(e))throw makeError("setByPath failed: expected array, found",e)}function expectObject(e){if(!e||e.constructor!==Object)throw makeError("setByPath failed: expected Object, found",e)}function getByPath(e,t){const r=pathParts(t);var n,s,a,i,o=e;for(n=0,s=r.length;o&&n<s;n++){var c=r[n];if(Array.isArray(c))for(a=0,i=c.length;o&&a<i;a++){o=o[c[a]]}else if(o.length)if(c.indexOf("=")>-1){const[e,...t]=c.split("=");o=byIdPath(o,e,t.join("="))}else o=o[a=parseInt(c,10)];else{if("="!==c[0])return;o=o[c.substr(1)]}}return o}function setByPath(e,t,r){let n=e;const s=pathParts(t);for(;n&&s.length;){const e=s.shift();if("string"==typeof e){const t=e.indexOf("=");if(t>-1){if(0===t?expectObject(n):expectArray(n),n=byIdPath(n,e.substr(0,t),e.substr(t+1),s.length?_newObject_:r),!s.length)return!0}else{expectArray(n);const t=parseInt(e,10);if(!s.length){if(r!==_delete_){if(n[t]===r)return!1;n[t]=r}else n.splice(t,1);return!0}n=n[t]}}else{if(!Array.isArray(e)||!e.length)throw new Error(`setByPath failed, bad path ${t}`);for(expectObject(n);e.length;){const t=e.shift();if(!e.length&&!s.length){if(r!==_delete_){if(n[t]===r)return!1;n[t]=r}else{if(!n.hasOwnProperty(t))return!1;delete n[t]}return!0}n=byKey(n,t,e.length?{}:[])}}}throw new Error(`setByPath(${e}, ${t}, ${r}) failed`)}const observerShouldBeRemoved=Symbol("observer should be removed"),registry={},listeners=[],validPath=/^\.?([^.[\](),])+(\.[^.[\](),]+|\[\d+\]|\[[^=[\](),]*=[^[\]()]+\])*$/,isValidPath=e=>validPath.test(e);class Listener{constructor(e,t){if("string"==typeof e)this.test=(t=>"string"==typeof t&&t.startsWith(e));else if(e instanceof RegExp)this.test=e.test.bind(e);else{if(!(e instanceof Function))throw new Error("expect listener test to be a string, RegExp, or test function");this.test=e}if("string"==typeof t)this.callback=((...e)=>{const r=xin[t];if(!r)throw new Error(`callback path ${t} does not exist`);r(...e)});else{if("function"!=typeof t)throw new Error("expect callback to be a path or function");this.callback=t}listeners.push(this)}}const touch=e=>{listeners.filter(t=>{let r;try{r=t.test(e)}catch(t){throw new Error(`listener test (${e}) threw ${t}`)}return r===observerShouldBeRemoved?(unobserve(t),!1):!!r}).forEach(t=>{try{t.callback(e)===observerShouldBeRemoved&&unobserve(t)}catch(t){throw new Error(`listener callback threw ${t} handling ${e}`)}})},observe=(e,t)=>new Listener(e,t),unobserve=e=>{let t;if(!((t=listeners.indexOf(e))>-1))throw new Error("unobserve failed, listener not found");return listeners.splice(t,1),!1},extendPath=(e="",t="")=>""===e?t:t.match(/^\d+$/)||t.includes("=")?`${e}[${t}]`:`${e}.${t}`,regHandler=(e="")=>({get(t,r){const n=r.match(/^([^.[]+)\.(.+)$/)||r.match(/^([^\]]+)(\[.+)/)||r.match(/^(\[[^\]]+\])\.(.+)$/)||r.match(/^(\[[^\]]+\])\[(.+)$/);if(n){const[,r,s]=n,a=extendPath(e,r),i=getByPath(t,r);return i&&"object"==typeof i?new Proxy(i,regHandler(a))[s]:i}if("_xinPath"===r)return e;if("_xinValue"===r)return t;if(r.startsWith("[")&&r.endsWith("]")&&(r=r.substr(1,r.length-2)),Object.prototype.hasOwnProperty.call(t,r)||Array.isArray(t)&&"string"==typeof r&&r.includes("=")){let n;if(r.includes("=")){const[e,s]=r.split("=");n=t.find(t=>`${getByPath(t,e)}`===s)}else n=t[r];if(!n||"object"!=typeof n||n.constructor!==Object&&n.constructor!==Array)return"function"==typeof n?n.bind(t):n;{const t=extendPath(e,r);return new Proxy(n,regHandler(t))}}return Array.isArray(t)?"function"==typeof t[r]?(...n)=>{const s=Array.prototype[r].apply(t,n);return touch(e),s}:t[Number(r)]:void 0},set(t,r,n){if(n&&n._xinPath)throw new Error("You cannot put xin proxies into the registry");const s=extendPath(e,r);if(!isValidPath(s))throw new Error(`setting invalid path ${s}`);return setByPath(registry,s,n)&&touch(s),!0}}),xin=new Proxy(registry,regHandler()),isAsync=e=>e&&e.constructor===(async()=>{}).constructor,describe=e=>null===e?"null":Array.isArray(e)?"array":"number"==typeof e&&isNaN(e)?"NaN":"string"==typeof e&&e.startsWith("#")?e:e instanceof Promise?"promise":"function"==typeof e?e.constructor===(async()=>{}).constructor?"async":"function":"object"==typeof e&&"Object"!==e.constructor.name?e.constructor.name:typeof e,parseFloatOrInfinity=e=>"-∞"===e?-1/0:"∞"===e[0]?1/0:parseFloat(e),inRange=(e,t)=>{let r,n;if(void 0===e)return!0;try{[,r,n]=(e||"").match(/^([[(]-?[\d.\u221E]+)?,?(-?[\d.\u221E]+[\])])?$/)}catch(t){throw new Error(`bad range ${e}`)}if(r){const e=parseFloatOrInfinity(r.substr(1));if("("===r[0]){if(t<=e)return!1}else if(t<e)return!1}if(n){const e=parseFloatOrInfinity(n);if(n.endsWith(")")){if(t>=e)return!1}else if(t>e)return!1}return!0},regExps={},regexpTest=(e,t)=>{return(regExps[e]?regExps[e]:regExps[e]=new RegExp(e)).test(t)},isInstanceOf=(e,t)=>{if("function"==typeof t)return e instanceof Function;{let r=Object.getPrototypeOf(e);for(;r.constructor&&r.constructor!==Object;){if(r.constructor.name===t)return!0;r=Object.getPrototypeOf(r)}return!1}},specificTypeMatch=(e,t)=>{const[,r,n,,s]=e.match(/^#([?]?)([^\s]+)(\s(.*))?$/)||[];if(r&&(null===t||void 0===t))return!0;const a=describe(t);switch(n){case"forbidden":return!1;case"any":return null!==t&&void 0!==t;case"native":return"function"==typeof t&&"function () { [native code] }"===t.toString()&&(!e||(isAsync(t)?e.match(/^async\b/):e.match(/^function\b/)));case"function":return"function"===a;case"number":return"number"===a&&inRange(s,t);case"int":return"number"===a&&t===Math.floor(t)&&inRange(s,t);case"union":return!!s.split("||").find(e=>specificTypeMatch(`#${e}`,t));case"enum":try{return s.split("|").map(JSON.parse).includes(t)}catch(e){throw new Error(`bad enum specification (${s}), expect JSON strings`)}case"void":return"undefined"===a||"null"===a;case"nothing":return"undefined"===a;case"string":return"string"===a;case"regexp":return"string"===a&&regexpTest(s,t);case"array":return Array.isArray(t);case"instance":return isInstanceOf(t,s);case"promise":return t instanceof Promise;case"object":return!!t&&"object"==typeof t&&!Array.isArray(t);default:if(a!==n)throw makeError("got",t,`expected "${e}", "${a}" does not match "${n}"`);return!0}},quoteIfString=e=>"string"==typeof e?`"${e}"`:"object"==typeof e?describe(e):e;function*arraySampler(e){let t=0;const r=Math.ceil(e.length/101);for(;t<e.length;)t<5?(yield{sample:e[t],i:t},t++):t>e.length-5?(yield{sample:e[t],i:t},t++):(yield{sample:e[t],i:t},t=Math.min(t+r,e.length-4))}const matchType=(e,t,r=[],n="")=>{const s=describe(e),a=describe(t);if(s.startsWith("#")?specificTypeMatch(s,t):s===a)if("array"===s){const s=!!t.length&&arraySampler(t);if(1===e.length&&s)for(const{sample:t,i:a}of s)matchType(e[0],t,r,`${n}[${a}]`);else if(e.length>1&&s)for(const{sample:t,i:a}of s){let s=!1;for(const r of e)if(0===matchType(r,t,[],"").length){s=!0;break}s||r.push(`${n}[${a}] had no matching type`)}}else"object"===s&&matchKeys(e,t,r,n);else r.push(`${n?n+" ":""}was ${quoteIfString(t)}, expected ${s}`);return r},legalVarName=/^[a-zA-Z_$][a-zA-Z_$0-9]*$/,matchKeys=(e,t,r=[],n="")=>{const s=new Set;for(const a of Object.keys(e))if(a.startsWith("#")){let i=legalVarName;try{"#"!==a&&(i=new RegExp(`^${a.substr(1)}$`))}catch(e){const t=`illegal regular expression in example key '${a}'`;throw r.push(t),makeError(t)}const o=Object.keys(t).filter(e=>i.test(e));for(const i of o)s.has(i)||(matchType(e[a],t[i],r,`${n}./^${a.substr(1)}$/:${i}`),s.add(i))}else if(a.endsWith("?")){const i=a.substr(0,a.length-1);Object.hasOwnProperty.call(t,i)&&(s.has(i)||(matchType(e[a],t[i],r,n+"."+i),s.add(i)))}else s.has(a)||(matchType(e[a],t[a],r,n+"."+a),s.add(a));return r};class TypeError{constructor(e){this.functionName=void 0,this.isParamFailure=!1,this.errors=[],Object.assign(this,e)}toString(){const{functionName:e,isParamFailure:t,errors:r}=this;return`${e} failed: bad ${t?"parameter":"result"}, ${JSON.stringify(r)}`}}const assignReadOnly=(e,t)=>{t={...t};for(const r of Object.keys(t)){const n=t[r];Object.defineProperty(e,r,{enumerable:!0,get:()=>n,set(e){throw new Error(`${r} is read-only`)}})}return e},matchParamTypes=(e,t)=>{for(let e=0;e<t.length;e++)if(t[e]instanceof TypeError)return t[e];const r=e.map((e,r)=>matchType(e,t[r]));return r.flat().length?r:[]},typeSafe=(e,t=[],r,n)=>{if(matchParamTypes(["#function","#?array","#?any","#?string"],[e,t,r,n])instanceof TypeError)throw new Error("typeSafe was passed bad paramters");n||(n=e.name||"anonymous");let s=0;return assignReadOnly(function(...a){s+=1;const i=matchParamTypes(t,a);if(i instanceof TypeError)return i;if(0===i.length){const t=e(...a),s=matchType(r,t);return 0===s.length?t:new TypeError({functionName:n,isParamFailure:!1,expected:r,found:t,errors:s})}return new TypeError({functionName:n,isParamFailure:!0,expected:t,found:a,errors:i})},{paramTypes:t,resultType:r,getCallCount:()=>s})};export{matchType,observe,observerShouldBeRemoved,typeSafe,unobserve,xin};
//# sourceMappingURL=dist/xin.min.mjs.map