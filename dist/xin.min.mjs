const stringify=t=>{try{return JSON.stringify(t)}catch(t){return"{has circular references}"}},makeError=(...t)=>new Error(t.map(stringify).join(" ")),now36=()=>new Date(parseInt("1000000000",36)+Date.now()).valueOf().toString(36).slice(1);let _seq=0;const seq=()=>(parseInt("10000",36)+ ++_seq).toString(36).substr(-5),id=()=>now36()+seq(),_delete_={},_newObject_={};function pathParts(t){if(!t||"/"===t)return[];if(Array.isArray(t))return t;{const r=[];for(;t.length;){var e=t.search(/\[[^\]]+\]/);if(-1===e){r.push(t.split("."));break}{const n=t.substr(0,e);t=t.substr(e),n&&r.push(n.split(".")),e=t.indexOf("]")+1,r.push(t.substr(1,e-2)),"."===t.substr(e,1)&&(e+=1),t=t.substr(e)}}return r}}const idPathMaps=new WeakMap;function buildIdPathValueMap(t,e){t&&!idPathMaps.get(t)&&idPathMaps.set(t,{}),idPathMaps.get(t)[e]||(idPathMaps.get(t)[e]={});const r=idPathMaps.get(t)[e];return"_auto_"===e?t.forEach((t,e)=>{void 0===t._auto_&&(t._auto_=id()),r[t._auto_+""]=e}):t.forEach((t,n)=>{r[getByPath(t,e)+""]=n}),r}function getIdPathMap(t,e){return idPathMaps.get(t)&&idPathMaps.get(t)[e]?idPathMaps.get(t)[e]:buildIdPathValueMap(t,e)}function keyToIndex(t,e,r){r+="";let n=getIdPathMap(t,e)[r];return void 0!==n&&getByPath(t[n],e)+""===r||(n=buildIdPathValueMap(t,e)[r]),n}function byKey(t,e,r){return t[e]||(t[e]=r),t[e]}function byIdPath(t,e,r,n){let s=e?keyToIndex(t,e,r):r;if(n===_delete_)return e?t.splice(s,1):delete t[s],null;if(n===_newObject_)e||t[s]||(t[s]={});else if(n)if(void 0!==s)t[s]=n;else{if(!e||getByPath(n,e)+""!=r+"")throw new Error(`byIdPath insert failed at [${e}=${r}]`);t.push(n),s=t.length-1}return t[s]}function expectArray(t){if(!Array.isArray(t))throw makeError("setByPath failed: expected array, found",t)}function expectObject(t){if(!t||t.constructor!==Object)throw makeError("setByPath failed: expected Object, found",t)}function getByPath(t,e){const r=pathParts(e);var n,s,i,a,o=t;for(n=0,s=r.length;o&&n<s;n++){var h=r[n];if(Array.isArray(h))for(i=0,a=h.length;o&&i<a;i++){o=o[h[i]]}else if(o.length)if(h.indexOf("=")>-1){const[t,...e]=h.split("=");o=byIdPath(o,t,e.join("="))}else o=o[i=parseInt(h,10)];else{if("="!==h[0])return null;o=o[h.substr(1)]}}return void 0===o?null:o}function setByPath(t,e,r){let n=t;const s=pathParts(e);for(;n&&s.length;){const t=s.shift();if("string"==typeof t){const e=t.indexOf("=");if(e>-1){if(0===e?expectObject(n):expectArray(n),n=byIdPath(n,t.substr(0,e),t.substr(e+1),s.length?_newObject_:r),!s.length)return!0}else{expectArray(n);const e=parseInt(t,10);if(!s.length)return r!==_delete_?n[e]=r:n.splice(e,1),!0;n=n[e]}}else{if(!Array.isArray(t)||!t.length)throw new Error(`setByPath failed, bad path ${e}`);for(expectObject(n);t.length;){const e=t.shift();if(!t.length&&!s.length)return r!==_delete_?n[e]=r:delete n[e],!0;n=byKey(n,e,t.length?{}:[])}}}throw new Error(`setByPath(${t}, ${e}, ${r}) failed`)}const observerShouldBeRemoved=Symbol("observer should be removed"),registry={},listeners=[],validPath=/^\.?([^.[\](),])+(\.[^.[\](),]+|\[\d+\]|\[[^=[\](),]*=[^[\]()]+\])*$/,isValidPath=t=>validPath.test(t);class Listener{constructor(t,e){if("string"==typeof t)this.test=(e=>"string"==typeof e&&e.startsWith(t));else if(t instanceof RegExp)this.test=t.test.bind(t);else{if(!(t instanceof Function))throw new Error("expect listener test to be a string, RegExp, or test function");this.test=t}if("string"==typeof e)this.callback=((...t)=>{const r=xin[e];if(!r)throw new Error(`callback path ${e} does not exist`);r(...t)});else{if("function"!=typeof e)throw new Error("expect callback to be a path or function");this.callback=e}listeners.push(this)}}const touch=t=>{listeners.filter(e=>{let r;try{r=e.test(t)}catch(e){throw new Error(`listener test (${t}) threw ${e}`)}return r===observerShouldBeRemoved?(unobserve(e),!1):!!r}).forEach(e=>{try{e.callback(t)===observerShouldBeRemoved&&unobserve(e)}catch(e){throw new Error(`listener callback threw ${e} handling ${t}`)}})},observe=(t,e)=>new Listener(t,e),unobserve=t=>{let e;if(!((e=listeners.indexOf(t))>-1))throw new Error("unobserve failed, listener not found");return listeners.splice(e,1),!1},extendPath=(t="",e="")=>""===t?e:e.match(/^\d+$/)||e.includes("=")?`${t}[${e}]`:`${t}.${e}`,regHandler=(t="")=>({get(e,r){const n=r.match(/^([^.[]+)\.(.+)$/)||r.match(/^([^\]]+)(\[.+)/)||r.match(/^(\[[^\]]+\])\.(.+)$/)||r.match(/^(\[[^\]]+\])\[(.+)$/);if(n){const[,r,s]=n,i=extendPath(t,r),a=getByPath(e,r);return a&&"object"==typeof a?new Proxy(a,regHandler(i))[s]:a}if("_xinPath"===r)return t;if("_xinValue"===r)return e;if(r.startsWith("[")&&r.endsWith("]")&&(r=r.substr(1,r.length-2)),Object.prototype.hasOwnProperty.call(e,r)||Array.isArray(e)&&"string"==typeof r&&r.includes("=")){let n;if(r.includes("=")){const[t,s]=r.split("=");n=e.find(e=>`${getByPath(e,t)}`===s)}else n=e[r];if(!n||"object"!=typeof n||n.constructor!==Object&&n.constructor!==Array)return"function"==typeof n?n.bind(e):n;{const e=extendPath(t,r);return new Proxy(n,regHandler(e))}}return Array.isArray(e)?"function"==typeof e[r]?(...n)=>{const s=Array.prototype[r].apply(e,n);return touch(t),s}:e[Number(r)]:void 0},set(e,r,n){if(n&&n._xinPath)throw new Error("You cannot put xin proxies into the registry");const s=extendPath(t,r);if(!isValidPath(s))throw new Error(`setting invalid path ${s}`);return setByPath(registry,s,n),touch(s),!0}}),xin=new Proxy(registry,regHandler());export{observe,observerShouldBeRemoved,unobserve,xin};
//# sourceMappingURL=dist/xin.min.mjs.map