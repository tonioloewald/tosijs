var xi=function(t){"use strict";const e=t=>{try{return JSON.stringify(t)}catch(t){return"{has circular references}"}},r=(...t)=>new Error(t.map(e).join(" "));let n=0;const s=()=>(()=>new Date(parseInt("1000000000",36)+Date.now()).valueOf().toString(36).slice(1))()+(()=>(parseInt("10000",36)+ ++n).toString(36).substr(-5))(),o={},i={};function a(t){if(!t)return[];if(Array.isArray(t))return t;{const r=[];for(;t.length;){var e=t.search(/\[[^\]]+\]/);if(-1===e){r.push(t.split("."));break}{const n=t.substr(0,e);t=t.substr(e),n&&r.push(n.split(".")),e=t.indexOf("]")+1,r.push(t.substr(1,e-2)),"."===t.substr(e,1)&&(e+=1),t=t.substr(e)}}return r}}const c=new WeakMap;function u(t,e){t&&!c.get(t)&&c.set(t,{}),c.get(t)[e]||(c.get(t)[e]={});const r=c.get(t)[e];return"_auto_"===e?t.forEach((t,e)=>{void 0===t._auto_&&(t._auto_=s()),r[t._auto_+""]=e}):t.forEach((t,n)=>{r[d(t,e)+""]=n}),r}function f(t,e,r){r+="";let n=function(t,e){return c.get(t)&&c.get(t)[e]?c.get(t)[e]:u(t,e)}(t,e)[r];return void 0!==n&&d(t[n],e)+""===r||(n=u(t,e)[r]),n}function l(t,e,r){return t[e]||(t[e]=r),t[e]}function h(t,e,r,n){let s=e?f(t,e,r):r;if(n===o)return t.splice(s,1),c.delete(t),Symbol("deleted");if(n===i)e||t[s]||(t[s]={});else if(n)if(void 0!==s)t[s]=n;else{if(!e||d(n,e)+""!=r+"")throw new Error(`byIdPath insert failed at [${e}=${r}]`);t.push(n),s=t.length-1}return t[s]}function p(t){if(!Array.isArray(t))throw r("setByPath failed: expected array, found",t)}function y(t){if(!t||t.constructor!==Object)throw r("setByPath failed: expected Object, found",t)}function d(t,e){const r=a(e);var n,s,o,i,c=t;for(n=0,s=r.length;c&&n<s;n++){var u=r[n];if(Array.isArray(u))for(o=0,i=u.length;c&&o<i;o++){c=c[u[o]]}else if(c.length)if(u.indexOf("=")>-1){const[t,...e]=u.split("=");c=h(c,t,e.join("="))}else c=c[o=parseInt(u,10)];else{if("="!==u[0])return;c=c[u.substr(1)]}}return c}const g=Symbol("observer should be removed"),b={},w=[],m=/^\.?([^.[\](),])+(\.[^.[\](),]+|\[\d+\]|\[[^=[\](),]*=[^[\]()]+\])*$/;const $=t=>{w.filter(e=>{let r;try{r=e.test(t)}catch(e){throw new Error(`listener test (${t}) threw ${e}`)}return r===g?(x(e),!1):!!r}).forEach(e=>{try{e.callback(t)===g&&x(e)}catch(e){throw new Error(`listener callback threw ${e} handling ${t}`)}})},x=t=>{let e;if(!((e=w.indexOf(t))>-1))throw new Error("unobserve failed, listener not found");return w.splice(e,1),!1},O=(t="",e="")=>""===t?e:e.match(/^\d+$/)||e.includes("=")?`${t}[${e}]`:`${t}.${e}`,v=(t="")=>({get(e,r){const n=r.match(/^([^.[]+)\.(.+)$/)||r.match(/^([^\]]+)(\[.+)/)||r.match(/^(\[[^\]]+\])\.(.+)$/)||r.match(/^(\[[^\]]+\])\[(.+)$/);if(n){const[,r,s]=n,o=O(t,r),i=d(e,r);return i&&"object"==typeof i?new Proxy(i,v(o))[s]:i}if("_xinPath"===r)return t;if("_xinValue"===r)return e;if(r.startsWith("[")&&r.endsWith("]")&&(r=r.substr(1,r.length-2)),Object.prototype.hasOwnProperty.call(e,r)||Array.isArray(e)&&"string"==typeof r&&r.includes("=")){let n;if(r.includes("=")){const[t,s]=r.split("=");n=e.find(e=>`${d(e,t)}`===s)}else n=e[r];if(!n||"object"!=typeof n||n.constructor!==Object&&n.constructor!==Array)return"function"==typeof n?n.bind(e):n;{const e=O(t,r);return new Proxy(n,v(e))}}return Array.isArray(e)?"function"==typeof e[r]?(...n)=>{const s=Array.prototype[r].apply(e,n);return $(t),s}:e[Number(r)]:void 0},set(e,r,n){if(n&&n._xinPath)throw new Error("You cannot put xin proxies into the registry");const s=O(t,r);if(!(t=>m.test(t))(s))throw new Error(`setting invalid path ${s}`);return function(t,e,r){let n=t;const s=a(e);for(;n&&s.length;){const t=s.shift();if("string"==typeof t){const e=t.indexOf("=");if(e>-1){if(0===e?y(n):p(n),n=h(n,t.substr(0,e),t.substr(e+1),s.length?i:r),!s.length)return!0}else{p(n);const e=parseInt(t,10);if(!s.length){if(r!==o){if(n[e]===r)return!1;n[e]=r}else n.splice(e,1);return!0}n=n[e]}}else{if(!Array.isArray(t)||!t.length)throw new Error(`setByPath failed, bad path ${e}`);for(y(n);t.length;){const e=t.shift();if(!t.length&&!s.length){if(r!==o){if(n[e]===r)return!1;n[e]=r}else{if(!n.hasOwnProperty(e))return!1;delete n[e]}return!0}n=l(n,e,t.length?{}:[])}}}throw new Error(`setByPath(${t}, ${e}, ${r}) failed`)}(b,s,n)&&$(s),!0}}),E=new Proxy(b,v()),j=t=>null===t?"null":Array.isArray(t)?"array":"number"==typeof t&&isNaN(t)?"NaN":"string"==typeof t&&t.startsWith("#")?t:t instanceof Promise?"promise":"function"==typeof t?t.constructor===(async()=>{}).constructor?"async":"function":"object"==typeof t&&"Object"!==t.constructor.name?t.constructor.name:typeof t,A=t=>"-∞"===t?-1/0:"∞"===t[0]?1/0:parseFloat(t),P=(t,e)=>{let r,n;if(void 0===t)return!0;try{[,r,n]=(t||"").match(/^([[(]-?[\d.\u221E]+)?,?(-?[\d.\u221E]+[\])])?$/)}catch(e){throw new Error(`bad range ${t}`)}if(r){const t=A(r.substr(1));if("("===r[0]){if(e<=t)return!1}else if(e<t)return!1}if(n){const t=A(n);if(n.endsWith(")")){if(e>=t)return!1}else if(e>t)return!1}return!0},S={},k=(t,e)=>{const[,n,s,,o]=t.match(/^#([?]?)([^\s]+)(\s(.*))?$/)||[];if(n&&(null===e||void 0===e))return!0;const i=j(e);switch(s){case"forbidden":return!1;case"any":return null!==e&&void 0!==e;case"native":return"function"==typeof e&&"function () { [native code] }"===e.toString()&&(!t||((t=>t&&t.constructor===(async()=>{}).constructor)(e)?t.match(/^async\b/):t.match(/^function\b/)));case"function":return"function"===i;case"number":return"number"===i&&P(o,e);case"int":return"number"===i&&e===Math.floor(e)&&P(o,e);case"union":return!!o.split("||").find(t=>k(`#${t}`,e));case"enum":try{return o.split("|").map(JSON.parse).includes(e)}catch(t){throw new Error(`bad enum specification (${o}), expect JSON strings`)}case"void":return"undefined"===i||"null"===i;case"nothing":return"undefined"===i;case"string":return"string"===i;case"regexp":return"string"===i&&(e=e,(S[o=o]?S[o]:S[o]=new RegExp(o)).test(e));case"array":return Array.isArray(e);case"instance":return((t,e)=>{if("function"==typeof e)return t instanceof Function;{let r=Object.getPrototypeOf(t);for(;r.constructor&&r.constructor!==Object;){if(r.constructor.name===e)return!0;r=Object.getPrototypeOf(r)}return!1}})(e,o);case"promise":return e instanceof Promise;case"object":return!!e&&"object"==typeof e&&!Array.isArray(e);default:if(i!==s)throw r("got",e,`expected "${t}", "${i}" does not match "${s}"`);return!0}};var N,_;const W=(t,e,r=[],n="")=>{const s=j(t),o=j(e);if(s.startsWith("#")?k(s,e):s===o)if("array"===s){const s=!!e.length&&function*(t){let e=0;const r=Math.ceil(t.length/101);for(;e<t.length;)e<5?(yield{sample:t[e],i:e},e++):e>t.length-5?(yield{sample:t[e],i:e},e++):(yield{sample:t[e],i:e},e=Math.min(e+r,t.length-4))}(e);if(1===t.length&&s)for(const{sample:e,i:o}of s)W(t[0],e,r,`${n}[${o}]`);else if(t.length>1&&s)for(const{sample:e,i:o}of s){let s=!1;for(const r of t)if(0===W(r,e,[],"").length){s=!0;break}s||r.push(`${n}[${o}] had no matching type`)}}else"object"===s&&B(t,e,r,n);else r.push(`${n?n+" ":""}was ${(t=>"string"==typeof t?`"${t}"`:"object"==typeof t?j(t):t)(e)}, expected ${s}`);return r},F=/^[a-zA-Z_$][a-zA-Z_$0-9]*$/,B=(t,e,n=[],s="")=>{const o=new Set;for(const i of Object.keys(t))if(i.startsWith("#")){let a=F;try{"#"!==i&&(a=new RegExp(`^${i.substr(1)}$`))}catch(t){const e=`illegal regular expression in example key '${i}'`;throw n.push(e),r(e)}const c=Object.keys(e).filter(t=>a.test(t));for(const r of c)o.has(r)||(W(t[i],e[r],n,`${s}./^${i.substr(1)}$/:${r}`),o.add(r))}else if(i.endsWith("?")){const r=i.substr(0,i.length-1);Object.hasOwnProperty.call(e,r)&&(o.has(r)||(W(t[i],e[r],n,s+"."+r),o.add(r)))}else o.has(i)||(W(t[i],e[i],n,s+"."+i),o.add(i));return n};class I{constructor(t){this.functionName=void 0,this.isParamFailure=!1,this.errors=[],Object.assign(this,t)}toString(){const{functionName:t,isParamFailure:e,errors:r}=this;return`${t} failed: bad ${e?"parameter":"result"}, ${JSON.stringify(r)}`}}const R=(t,e)=>{for(let t=0;t<e.length;t++)if(e[t]instanceof I)return e[t];const r=t.map((t,r)=>W(t,e[r]));return r.flat().length?r:[]};return t.matchType=W,t.observe=((t,e)=>new class{constructor(t,e){if("string"==typeof t)this.test=(e=>"string"==typeof e&&e.startsWith(t));else if(t instanceof RegExp)this.test=t.test.bind(t);else{if(!(t instanceof Function))throw new Error("expect listener test to be a string, RegExp, or test function");this.test=t}if("string"==typeof e)this.callback=((...t)=>{const r=E[e];if(!r)throw new Error(`callback path ${e} does not exist`);r(...t)});else{if("function"!=typeof e)throw new Error("expect callback to be a path or function");this.callback=e}w.push(this)}}(t,e)),t.observerShouldBeRemoved=g,t.typeSafe=((t,e=[],r,n)=>{if(R(["#function","#?array","#?any","#?string"],[t,e,r,n])instanceof I)throw new Error("typeSafe was passed bad paramters");n||(n=t.name||"anonymous");let s=0;return((t,e)=>{e={...e};for(const r of Object.keys(e)){const n=e[r];Object.defineProperty(t,r,{enumerable:!0,get:()=>n,set(t){throw new Error(`${r} is read-only`)}})}return t})(function(...o){s+=1;const i=R(e,o);if(i instanceof I)return i;if(0===i.length){const e=t(...o),s=W(r,e);return 0===s.length?e:new I({functionName:n,isParamFailure:!1,expected:r,found:e,errors:s})}return new I({functionName:n,isParamFailure:!0,expected:e,found:o,errors:i})},{paramTypes:e,resultType:r,getCallCount:()=>s})}),t.unobserve=x,t.xin=E,t}({});
//# sourceMappingURL=dist/xin.iife.min.js.map