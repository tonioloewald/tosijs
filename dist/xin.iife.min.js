var xi=function(t){"use strict";const e=t=>{try{return JSON.stringify(t)}catch(t){return"{has circular references}"}},r=(...t)=>new Error(t.map(e).join(" "));let n=0;const s=()=>(()=>new Date(parseInt("1000000000",36)+Date.now()).valueOf().toString(36).slice(1))()+(()=>(parseInt("10000",36)+ ++n).toString(36).substr(-5))(),o={},i={};function c(t){if(!t||"/"===t)return[];if(Array.isArray(t))return t;{const r=[];for(;t.length;){var e=t.search(/\[[^\]]+\]/);if(-1===e){r.push(t.split("."));break}{const n=t.substr(0,e);t=t.substr(e),n&&r.push(n.split(".")),e=t.indexOf("]")+1,r.push(t.substr(1,e-2)),"."===t.substr(e,1)&&(e+=1),t=t.substr(e)}}return r}}const a=new WeakMap;function f(t,e){t&&!a.get(t)&&a.set(t,{}),a.get(t)[e]||(a.get(t)[e]={});const r=a.get(t)[e];return"_auto_"===e?t.forEach((t,e)=>{void 0===t._auto_&&(t._auto_=s()),r[t._auto_+""]=e}):t.forEach((t,n)=>{r[d(t,e)+""]=n}),r}function l(t,e,r){r+="";let n=function(t,e){return a.get(t)&&a.get(t)[e]?a.get(t)[e]:f(t,e)}(t,e)[r];return void 0!==n&&d(t[n],e)+""===r||(n=f(t,e)[r]),n}function u(t,e,r){return t[e]||(t[e]=r),t[e]}function h(t,e,r,n){let s=e?l(t,e,r):r;if(n===o)return e?t.splice(s,1):delete t[s],null;if(n===i)e||t[s]||(t[s]={});else if(n)if(void 0!==s)t[s]=n;else{if(!e||d(n,e)+""!=r+"")throw new Error(`byIdPath insert failed at [${e}=${r}]`);t.push(n),s=t.length-1}return t[s]}function p(t){if(!Array.isArray(t))throw r("setByPath failed: expected array, found",t)}function y(t){if(!t||t.constructor!==Object)throw r("setByPath failed: expected Object, found",t)}function d(t,e){const r=c(e);var n,s,o,i,a=t;for(n=0,s=r.length;a&&n<s;n++){var f=r[n];if(Array.isArray(f))for(o=0,i=f.length;a&&o<i;o++){a=a[f[o]]}else if(a.length)if(f.indexOf("=")>-1){const[t,...e]=f.split("=");a=h(a,t,e.join("="))}else a=a[o=parseInt(f,10)];else{if("="!==f[0])return null;a=a[f.substr(1)]}}return void 0===a?null:a}const b=Symbol("observer should be removed"),g={},w=[],$=/^\.?([^.[\](),])+(\.[^.[\](),]+|\[\d+\]|\[[^=[\](),]*=[^[\]()]+\])*$/;const x=t=>{w.filter(e=>{let r;try{r=e.test(t)}catch(e){throw new Error(`listener test (${t}) threw ${e}`)}return r===b?(v(e),!1):!!r}).forEach(e=>{try{e.callback(t)===b&&v(e)}catch(e){throw new Error(`listener callback threw ${e} handling ${t}`)}})},v=t=>{let e;if(!((e=w.indexOf(t))>-1))throw new Error("unobserve failed, listener not found");return w.splice(e,1),!1},E=(t="",e="")=>""===t?e:e.match(/^\d+$/)||e.includes("=")?`${t}[${e}]`:`${t}.${e}`,A=(t="")=>({get(e,r){const n=r.match(/^([^.[]+)\.(.+)$/)||r.match(/^([^\]]+)(\[.+)/)||r.match(/^(\[[^\]]+\])\.(.+)$/)||r.match(/^(\[[^\]]+\])\[(.+)$/);if(n){const[,r,s]=n,o=E(t,r),i=d(e,r);return i&&"object"==typeof i?new Proxy(i,A(o))[s]:i}if("_xinPath"===r)return t;if("_xinValue"===r)return e;if(r.startsWith("[")&&r.endsWith("]")&&(r=r.substr(1,r.length-2)),Object.prototype.hasOwnProperty.call(e,r)||Array.isArray(e)&&"string"==typeof r&&r.includes("=")){let n;if(r.includes("=")){const[t,s]=r.split("=");n=e.find(e=>`${d(e,t)}`===s)}else n=e[r];if(!n||"object"!=typeof n||n.constructor!==Object&&n.constructor!==Array)return"function"==typeof n?n.bind(e):n;{const e=E(t,r);return new Proxy(n,A(e))}}return Array.isArray(e)?"function"==typeof e[r]?(...n)=>{const s=Array.prototype[r].apply(e,n);return x(t),s}:e[Number(r)]:void 0},set(e,r,n){if(n&&n._xinPath)throw new Error("You cannot put xin proxies into the registry");const s=E(t,r);if(!(t=>$.test(t))(s))throw new Error(`setting invalid path ${s}`);return function(t,e,r){let n=t;const s=c(e);for(;n&&s.length;){const t=s.shift();if("string"==typeof t){const e=t.indexOf("=");if(e>-1){if(0===e?y(n):p(n),n=h(n,t.substr(0,e),t.substr(e+1),s.length?i:r),!s.length)return!0}else{p(n);const e=parseInt(t,10);if(!s.length)return r!==o?n[e]=r:n.splice(e,1),!0;n=n[e]}}else{if(!Array.isArray(t)||!t.length)throw new Error(`setByPath failed, bad path ${e}`);for(y(n);t.length;){const e=t.shift();if(!t.length&&!s.length)return r!==o?n[e]=r:delete n[e],!0;n=u(n,e,t.length?{}:[])}}}throw new Error(`setByPath(${t}, ${e}, ${r}) failed`)}(g,s,n),x(s),!0}}),O=new Proxy(g,A());return t.observe=((t,e)=>new class{constructor(t,e){if("string"==typeof t)this.test=(e=>"string"==typeof e&&e.startsWith(t));else if(t instanceof RegExp)this.test=t.test.bind(t);else{if(!(t instanceof Function))throw new Error("expect listener test to be a string, RegExp, or test function");this.test=t}if("string"==typeof e)this.callback=((...t)=>{const r=O[e];if(!r)throw new Error(`callback path ${e} does not exist`);r(...t)});else{if("function"!=typeof e)throw new Error("expect callback to be a path or function");this.callback=e}w.push(this)}}(t,e)),t.observerShouldBeRemoved=b,t.unobserve=v,t.xin=O,t}({});
//# sourceMappingURL=dist/xin.iife.min.js.map