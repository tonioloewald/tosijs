"use strict";var react=require("react");const stringify=e=>{try{return JSON.stringify(e)}catch(e){return"{has circular references}"}},makeError=(...e)=>new Error(e.map(stringify).join(" ")),now36=()=>new Date(parseInt("1000000000",36)+Date.now()).valueOf().toString(36).slice(1);let _seq=0;const seq=()=>(parseInt("10000",36)+ ++_seq).toString(36).substr(-5),id=()=>now36()+seq(),_delete_={},_newObject_={};function pathParts(e){if(!e)return[];if(Array.isArray(e))return e;for(var t=[];e.length;){var r=e.search(/\[[^\]]+\]/);if(-1===r){t.push(e.split("."));break}var n=e.substr(0,r);e=e.substr(r),n&&t.push(n.split(".")),r=e.indexOf("]")+1,t.push(e.substr(1,r-2)),"."===e.substr(r,1)&&(r+=1),e=e.substr(r)}return t}const idPathMaps=new WeakMap;function buildIdPathValueMap(e,r){e&&!idPathMaps.get(e)&&idPathMaps.set(e,{}),idPathMaps.get(e)[r]||(idPathMaps.get(e)[r]={});const n=idPathMaps.get(e)[r];return"_auto_"===r?e.forEach((e,t)=>{void 0===e._auto_&&(e._auto_=id()),n[e._auto_+""]=t}):e.forEach((e,t)=>{n[getByPath(e,r)+""]=t}),n}function getIdPathMap(e,t){return idPathMaps.get(e)&&idPathMaps.get(e)[t]?idPathMaps.get(e)[t]:buildIdPathValueMap(e,t)}function keyToIndex(e,t,r){r+="";let n=getIdPathMap(e,t)[r];return n=void 0!==n&&getByPath(e[n],t)+""===r?n:buildIdPathValueMap(e,t)[r]}function byKey(e,t,r){return e[t]||(e[t]=r),e[t]}function byIdPath(e,t,r,n){let a=t?keyToIndex(e,t,r):r;if(n===_delete_)return e.splice(a,1),idPathMaps.delete(e),Symbol("deleted");if(n===_newObject_)t||e[a]||(e[a]={});else if(n)if(void 0!==a)e[a]=n;else{if(!t||getByPath(n,t)+""!=r+"")throw new Error(`byIdPath insert failed at [${t}=${r}]`);e.push(n),a=e.length-1}return e[a]}function expectArray(e){if(!Array.isArray(e))throw makeError("setByPath failed: expected array, found",e)}function expectObject(e){if(!e||e.constructor!==Object)throw makeError("setByPath failed: expected Object, found",e)}function getByPath(e,t){for(var r,n,a=pathParts(t),s=e,i=0,o=a.length;s&&i<o;i++){var c,u,f=a[i];if(Array.isArray(f))for(r=0,n=f.length;s&&r<n;r++)s=s[f[r]];else if(s.length)s=-1<f.indexOf("=")?([c,...u]=f.split("="),byIdPath(s,c,u.join("="))):s[r=parseInt(f,10)];else{if("="!==f[0])return;s=s[f.substr(1)]}}return s}function setByPath(e,t,r){let n=e;for(var a=pathParts(t);n&&a.length;){var s=a.shift();if("string"==typeof s){var i=s.indexOf("=");if(-1<i){(0===i?expectObject:expectArray)(n);var o=s.substr(0,i),i=s.substr(i+1);if(n=byIdPath(n,o,i,a.length?_newObject_:r),!a.length)return!0}else{expectArray(n);o=parseInt(s,10);if(!a.length){if(r!==_delete_){if(n[o]===r)return!1;n[o]=r}else n.splice(o,1);return!0}n=n[o]}}else{if(!Array.isArray(s)||!s.length)throw new Error("setByPath failed, bad path "+t);for(expectObject(n);s.length;){var c=s.shift();if(!s.length&&!a.length){if(r!==_delete_){if(n[c]===r)return!1;n[c]=r}else{if(!n.hasOwnProperty(c))return!1;delete n[c]}return!0}n=byKey(n,c,s.length?{}:[])}}}throw new Error(`setByPath(${e}, ${t}, ${r}) failed`)}const observerShouldBeRemoved=Symbol("observer should be removed"),ARRAY_MUTATIONS=["sort","splice","copyWithin","fill","pop","push","reverse","shift","unshift"],registry={},listeners=[],validPath=/^\.?([^.[\](),])+(\.[^.[\](),]+|\[\mad+\]|\[[^=[\](),]*=[^[\]()]+\])*$/,isValidPath=e=>validPath.test(e);class Listener{constructor(t,r){if("string"==typeof t)this.test=e=>"string"==typeof e&&e.startsWith(t);else if(t instanceof RegExp)this.test=t.test.bind(t);else{if(!(t instanceof Function))throw new Error("expect listener test to be a string, RegExp, or test function");this.test=t}if("string"==typeof r)this.callback=(...e)=>{var t=xin[r];if(!t)throw new Error(`callback path ${r} does not exist`);t(...e)};else{if("function"!=typeof r)throw new Error("expect callback to be a path or function");this.callback=r}listeners.push(this)}}const touch=r=>{listeners.filter(e=>{let t;try{t=e.test(r)}catch(e){throw new Error(`listener test (${r}) threw `+e)}return t===observerShouldBeRemoved?(unobserve(e),!1):!!t}).forEach(e=>{try{e.callback(r)===observerShouldBeRemoved&&unobserve(e)}catch(e){throw new Error(`listener callback threw ${e} handling `+r)}})},observe=(e,t)=>new Listener(e,t),unobserve=e=>{e=listeners.indexOf(e);if(-1<e)return listeners.splice(e,1),!1;throw new Error("unobserve failed, listener not found")},extendPath=(e="",t="")=>""===e?t:t.match(/^\d+$/)||t.includes("=")?e+`[${t}]`:e+"."+t,regHandler=(o="")=>({get(t,r){var e,n,a=r.match(/^([^.[]+)\.(.+)$/)||r.match(/^([^\]]+)(\[.+)/)||r.match(/^(\[[^\]]+\])\.(.+)$/)||r.match(/^(\[[^\]]+\])\[(.+)$/);if(a)return[,a,e]=a,n=extendPath(o,a),(a=getByPath(t,a))&&"object"==typeof a?new Proxy(a,regHandler(n))[e]:a;if("_xinPath"===r)return o;if("_xinValue"===r)return t;if(r.startsWith("[")&&r.endsWith("]")&&(r=r.substr(1,r.length-2)),Object.prototype.hasOwnProperty.call(t,r)||Array.isArray(t)&&"string"==typeof r&&r.includes("=")){let e;if(r.includes("=")){const[s,i]=r.split("=");e=t.find(e=>""+getByPath(e,s)===i)}else e=t[r];return!e||"object"!=typeof e||e.constructor!==Object&&e.constructor!==Array?"function"==typeof e?e.bind(t):e:(n=extendPath(o,r),new Proxy(e,regHandler(n)))}return Array.isArray(t)?"function"==typeof t[r]?(...e)=>{e=Array.prototype[r].apply(t,e);return ARRAY_MUTATIONS.includes(r)&&touch(o),e}:t[Number(r)]:void 0},set(e,t,r){if(r&&r._xinPath)throw new Error("You cannot put xin proxies into the registry");t=extendPath(o,t);if(isValidPath(t))return setByPath(registry,t,r)&&touch(t),!0;throw new Error("setting invalid path "+t)}}),xin=new Proxy(registry,regHandler()),useXin=(t,e="")=>{const[r,n]=react.useState(xin[t]||e);react.useEffect(()=>{const e=observe(t,e=>{n(xin[e])});return()=>{unobserve(e)}});return[r,e=>{xin[t]=e}]},isAsync=e=>e&&e.constructor===(async()=>{}).constructor,describe=e=>null===e?"null":Array.isArray(e)?"array":"number"==typeof e&&isNaN(e)?"NaN":"string"==typeof e&&e.startsWith("#")?e:e instanceof Promise?"promise":"function"==typeof e?e.constructor===(async()=>{}).constructor?"async":"function":"object"==typeof e&&"Object"!==e.constructor.name?e.constructor.name:typeof e,parseFloatOrInfinity=e=>"-∞"===e?-1/0:"∞"===e[0]?1/0:parseFloat(e),inRange=(t,e)=>{let r,n;if(void 0!==t){try{[,r,n]=(t||"").match(/^([[(]-?[\d.\u221E]+)?,?(-?[\d.\u221E]+[\])])?$/)}catch(e){throw new Error("bad range "+t)}if(r){t=parseFloatOrInfinity(r.substr(1));if("("===r[0]){if(e<=t)return!1}else if(e<t)return!1}if(n){t=parseFloatOrInfinity(n);if(n.endsWith(")")){if(t<=e)return!1}else if(t<e)return!1}}return!0},regExps={},regexpTest=(e,t)=>{return(regExps[e]||(regExps[e]=new RegExp(e))).test(t)},isInstanceOf=(t,r)=>{if("function"==typeof r)return t instanceof Function;{let e=Object.getPrototypeOf(t);for(;e.constructor&&e.constructor!==Object;){if(e.constructor.name===r)return!0;e=Object.getPrototypeOf(e)}return!1}},specificTypeMatch=(e,t)=>{var[,r,n,,a]=e.match(/^#([?]?)([^\s]+)(\s(.*))?$/)||[];if(r&&null==t)return!0;var s=describe(t);switch(n){case"forbidden":return!1;case"any":return null!=t;case"native":return"function"!=typeof t||"function () { [native code] }"!==t.toString()?!1:!e||(isAsync(t)?e.match(/^async\b/):e.match(/^function\b/));case"function":return"function"!==s?!1:!0;case"number":return"number"!==s?!1:inRange(a,t);case"int":return"number"!==s||t!==Math.floor(t)?!1:inRange(a,t);case"union":return!!a.split("||").find(e=>specificTypeMatch("#"+e,t));case"enum":try{return a.split("|").map(JSON.parse).includes(t)}catch(e){throw new Error(`bad enum specification (${a}), expect JSON strings`)}case"void":return"undefined"===s||"null"===s;case"nothing":return"undefined"===s;case"string":return"string"===s;case"regexp":return"string"===s&&regexpTest(a,t);case"array":return Array.isArray(t);case"instance":return isInstanceOf(t,a);case"promise":return t instanceof Promise;case"object":return!!t&&"object"==typeof t&&!Array.isArray(t);default:if(s!==n)throw makeError("got",t,`expected "${e}", "${s}" does not match "${n}"`);return!0}},quoteIfString=e=>"string"==typeof e?`"${e}"`:"object"==typeof e?describe(e):e;function*arraySampler(e){let t=0;for(var r=Math.ceil(e.length/101);t<e.length;)t<5||t>e.length-5?(yield{sample:e[t],i:t},t++):(yield{sample:e[t],i:t},t=Math.min(t+r,e.length-4))}const matchType=(t,e,r=[],n="")=>{var a=describe(t),s=describe(e);if(a.startsWith("#")?specificTypeMatch(a,e):a===s)if("array"===a){s=!!e.length&&arraySampler(e);if(1===t.length&&s)for(var{sample:i,i:o}of s)matchType(t[0],i,r,`${n}[${o}]`);else if(1<t.length&&s)for(var{sample:c,i:u}of s){let e=!1;for(const f of t)if(0===matchType(f,c,[],"").length){e=!0;break}e||r.push(`${n}[${u}] had no matching type`)}}else"object"===a&&matchKeys(t,e,r,n);else r.push(`${n?n+" ":""}was ${quoteIfString(e)}, expected `+a);return r},legalVarName=/^[a-zA-Z_$][a-zA-Z_$0-9]*$/,matchKeys=(e,r,n=[],a="")=>{var s=new Set;for(const o of Object.keys(e))if(o.startsWith("#")){let t=legalVarName;try{"#"!==o&&(t=new RegExp(`^${o.substr(1)}$`))}catch(e){var i=`illegal regular expression in example key '${o}'`;throw n.push(i),makeError(i)}for(const c of Object.keys(r).filter(e=>t.test(e)))s.has(c)||(matchType(e[o],r[c],n,`${a}./^${o.substr(1)}$/:`+c),s.add(c))}else o.endsWith("?")?(i=o.substr(0,o.length-1),Object.hasOwnProperty.call(r,i)&&!s.has(i)&&(matchType(e[o],r[i],n,a+"."+i),s.add(i))):s.has(o)||(matchType(e[o],r[o],n,a+"."+o),s.add(o));return n};class TypeError{constructor(e){this.functionName=void 0,this.isParamFailure=!1,this.errors=[],Object.assign(this,e)}toString(){var{functionName:e,isParamFailure:t,errors:r}=this;return e+` failed: bad ${t?"parameter":"result"}, `+JSON.stringify(r)}}const assignReadOnly=(e,t)=>{t={...t};for(const r of Object.keys(t)){const n=t[r];Object.defineProperty(e,r,{enumerable:!0,get(){return n},set(e){throw new Error(r+" is read-only")}})}return e},matchParamTypes=(e,r)=>{for(let e=0;e<r.length;e++)if(r[e]instanceof TypeError)return r[e];e=e.map((e,t)=>matchType(e,r[t]));return e.flat().length?e:[]},typeSafe=(a,s=[],i=void 0,o=void 0)=>{if(matchParamTypes(["#function","#?array","#?any","#?string"],[a,s,i,o])instanceof TypeError)throw new Error("typeSafe was passed bad paramters");o=o||a.name||"anonymous";let c=0;return assignReadOnly(function(...e){c+=1;var t,r,n=matchParamTypes(s,e);return n instanceof TypeError?n:0===n.length?(t=a(...e),0===(r=matchType(i,t)).length?t:new TypeError({functionName:o,isParamFailure:!1,expected:i,found:t,errors:r})):new TypeError({functionName:o,isParamFailure:!0,expected:s,found:e,errors:n})},{paramTypes:s,resultType:i,getCallCount:()=>c})},filterArray=(e,t)=>{if(Array.isArray(t)){if(0===e.length)return[...t];var r=[];for(const a of t){var n=e.find(e=>0===matchType(e,a).length);void 0!==n&&r.push(filter(n,a))}return r}},filterObject=(e,t)=>{if(!matchType(e,t).length){var r={};for(const a of Object.keys(e)){var n=filter(e[a],t[a]);void 0!==n&&(r[a]=n)}return r}},filter=(e,t)=>{if(null!=t&&("object"==typeof t||!matchType(e,t).length))return Array.isArray(e)?filterArray(e,t):"object"==typeof e?filterObject(e,t):matchType(t,e).length?void 0:t};exports.filter=filter,exports.matchType=matchType,exports.observe=observe,exports.observerShouldBeRemoved=observerShouldBeRemoved,exports.typeSafe=typeSafe,exports.unobserve=unobserve,exports.useXin=useXin,exports.xin=xin;
//# sourceMappingURL=dist/index.min.js.map